<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MARTe2: MARTe::Endianity Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MARTe2
   </div>
   <div id="projectbrief">C++ real-time application development framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceMARTe.html">MARTe</a></li><li class="navelem"><a class="el" href="namespaceMARTe_1_1Endianity.html">Endianity</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">MARTe::Endianity Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace which defines a collection of functions for dealing with endianity, taking into account the endianity of the current architecture.  
<a href="namespaceMARTe_1_1Endianity.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a076cea137576f8a24912a7d272375584"><td class="memItemLeft" align="right" valign="top">uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a076cea137576f8a24912a7d272375584">Type</a> ()</td></tr>
<tr class="memdesc:a076cea137576f8a24912a7d272375584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the target (i.e.  <a href="namespaceMARTe_1_1Endianity.html#a076cea137576f8a24912a7d272375584">More...</a><br /></td></tr>
<tr class="separator:a076cea137576f8a24912a7d272375584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1835da2a8a1ad0fb39a6ad871f5c2948"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a1835da2a8a1ad0fb39a6ad871f5c2948">FromBigEndian</a> (volatile float64 &amp;x)</td></tr>
<tr class="memdesc:a1835da2a8a1ad0fb39a6ad871f5c2948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a number (float64) from big endian to the target operating system endianity.  <a href="namespaceMARTe_1_1Endianity.html#a1835da2a8a1ad0fb39a6ad871f5c2948">More...</a><br /></td></tr>
<tr class="separator:a1835da2a8a1ad0fb39a6ad871f5c2948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a058cb32699e9abaa33936c2d204f5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a5a058cb32699e9abaa33936c2d204f5a">FromBigEndian</a> (volatile float32 &amp;x)</td></tr>
<tr class="memdesc:a5a058cb32699e9abaa33936c2d204f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a number (float32) from big endian to the target operating system endianity.  <a href="namespaceMARTe_1_1Endianity.html#a5a058cb32699e9abaa33936c2d204f5a">More...</a><br /></td></tr>
<tr class="separator:a5a058cb32699e9abaa33936c2d204f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0538f8604b9358f1b81a952151498fe4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a0538f8604b9358f1b81a952151498fe4">FromBigEndian</a> (volatile uint64 &amp;x)</td></tr>
<tr class="memdesc:a0538f8604b9358f1b81a952151498fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a number (uint64) from big endian to the target operating system endianity.  <a href="namespaceMARTe_1_1Endianity.html#a0538f8604b9358f1b81a952151498fe4">More...</a><br /></td></tr>
<tr class="separator:a0538f8604b9358f1b81a952151498fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41bbb89bfee6b762f610cad4e94472a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a41bbb89bfee6b762f610cad4e94472a4">FromBigEndian</a> (volatile uint32 &amp;x)</td></tr>
<tr class="memdesc:a41bbb89bfee6b762f610cad4e94472a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a number (uint32) from big endian to the target operating system endianity.  <a href="namespaceMARTe_1_1Endianity.html#a41bbb89bfee6b762f610cad4e94472a4">More...</a><br /></td></tr>
<tr class="separator:a41bbb89bfee6b762f610cad4e94472a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1266511817252390c335ca754e75ff65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a1266511817252390c335ca754e75ff65">FromBigEndian</a> (volatile uint16 &amp;x)</td></tr>
<tr class="memdesc:a1266511817252390c335ca754e75ff65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a number (uint16) from big endian to the target operating system endianity.  <a href="namespaceMARTe_1_1Endianity.html#a1266511817252390c335ca754e75ff65">More...</a><br /></td></tr>
<tr class="separator:a1266511817252390c335ca754e75ff65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f897a624996701ef1dc1db22a12dc0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#af2f897a624996701ef1dc1db22a12dc0">FromBigEndian</a> (volatile int64 &amp;x)</td></tr>
<tr class="memdesc:af2f897a624996701ef1dc1db22a12dc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a number (int64) from big endian to the target operating system endianity.  <a href="namespaceMARTe_1_1Endianity.html#af2f897a624996701ef1dc1db22a12dc0">More...</a><br /></td></tr>
<tr class="separator:af2f897a624996701ef1dc1db22a12dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e6d0d3ce93d8759742c020e2cfab2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a56e6d0d3ce93d8759742c020e2cfab2e">FromBigEndian</a> (volatile int32 &amp;x)</td></tr>
<tr class="memdesc:a56e6d0d3ce93d8759742c020e2cfab2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a number (int32) from big endian to the target operating system endianity.  <a href="namespaceMARTe_1_1Endianity.html#a56e6d0d3ce93d8759742c020e2cfab2e">More...</a><br /></td></tr>
<tr class="separator:a56e6d0d3ce93d8759742c020e2cfab2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4882fb19e136d5d23ff09507fbb1e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a7e4882fb19e136d5d23ff09507fbb1e3">FromBigEndian</a> (volatile int16 &amp;x)</td></tr>
<tr class="memdesc:a7e4882fb19e136d5d23ff09507fbb1e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a number (int16) from big endian to the target operating system endianity.  <a href="namespaceMARTe_1_1Endianity.html#a7e4882fb19e136d5d23ff09507fbb1e3">More...</a><br /></td></tr>
<tr class="separator:a7e4882fb19e136d5d23ff09507fbb1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3854424f7622093eeb179c3f3d08ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a1d3854424f7622093eeb179c3f3d08ad">FromLittleEndian</a> (volatile float64 &amp;x)</td></tr>
<tr class="memdesc:a1d3854424f7622093eeb179c3f3d08ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a number (float64) from little endian to the target operating system endianity.  <a href="namespaceMARTe_1_1Endianity.html#a1d3854424f7622093eeb179c3f3d08ad">More...</a><br /></td></tr>
<tr class="separator:a1d3854424f7622093eeb179c3f3d08ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ccc26c0f66b834cd5beedba32287239"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a5ccc26c0f66b834cd5beedba32287239">FromLittleEndian</a> (volatile float32 &amp;x)</td></tr>
<tr class="memdesc:a5ccc26c0f66b834cd5beedba32287239"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a number (float32) from little endian to the target operating system endianity.  <a href="namespaceMARTe_1_1Endianity.html#a5ccc26c0f66b834cd5beedba32287239">More...</a><br /></td></tr>
<tr class="separator:a5ccc26c0f66b834cd5beedba32287239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98109ea727f5afd0c81aa5984b575d68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a98109ea727f5afd0c81aa5984b575d68">FromLittleEndian</a> (volatile uint64 &amp;x)</td></tr>
<tr class="memdesc:a98109ea727f5afd0c81aa5984b575d68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a number (uint64) from little endian to the target operating system endianity.  <a href="namespaceMARTe_1_1Endianity.html#a98109ea727f5afd0c81aa5984b575d68">More...</a><br /></td></tr>
<tr class="separator:a98109ea727f5afd0c81aa5984b575d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23553e472227cade18963bdccca4e034"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a23553e472227cade18963bdccca4e034">FromLittleEndian</a> (volatile uint32 &amp;x)</td></tr>
<tr class="memdesc:a23553e472227cade18963bdccca4e034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a number (uint32) from little endian to the target operating system endianity.  <a href="namespaceMARTe_1_1Endianity.html#a23553e472227cade18963bdccca4e034">More...</a><br /></td></tr>
<tr class="separator:a23553e472227cade18963bdccca4e034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3fb678f27ceea0be1869b53242c076a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#aa3fb678f27ceea0be1869b53242c076a">FromLittleEndian</a> (volatile uint16 &amp;x)</td></tr>
<tr class="memdesc:aa3fb678f27ceea0be1869b53242c076a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a number (uint16) from little endian to the target operating system endianity.  <a href="namespaceMARTe_1_1Endianity.html#aa3fb678f27ceea0be1869b53242c076a">More...</a><br /></td></tr>
<tr class="separator:aa3fb678f27ceea0be1869b53242c076a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b654ac0250e1e71c808c8fcc0a98c73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a5b654ac0250e1e71c808c8fcc0a98c73">FromLittleEndian</a> (volatile int64 &amp;x)</td></tr>
<tr class="memdesc:a5b654ac0250e1e71c808c8fcc0a98c73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a number (int64) from little endian to the target operating system endianity.  <a href="namespaceMARTe_1_1Endianity.html#a5b654ac0250e1e71c808c8fcc0a98c73">More...</a><br /></td></tr>
<tr class="separator:a5b654ac0250e1e71c808c8fcc0a98c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65cb21d4c55be2904a9a833c1ff9eed3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a65cb21d4c55be2904a9a833c1ff9eed3">FromLittleEndian</a> (volatile int32 &amp;x)</td></tr>
<tr class="memdesc:a65cb21d4c55be2904a9a833c1ff9eed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a number (int32) from little endian to the target operating system endianity.  <a href="namespaceMARTe_1_1Endianity.html#a65cb21d4c55be2904a9a833c1ff9eed3">More...</a><br /></td></tr>
<tr class="separator:a65cb21d4c55be2904a9a833c1ff9eed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300e8ada11a54048fa79458f37087591"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a300e8ada11a54048fa79458f37087591">FromLittleEndian</a> (volatile int16 &amp;x)</td></tr>
<tr class="memdesc:a300e8ada11a54048fa79458f37087591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a number (int16) from little endian to the target operating system endianity.  <a href="namespaceMARTe_1_1Endianity.html#a300e8ada11a54048fa79458f37087591">More...</a><br /></td></tr>
<tr class="separator:a300e8ada11a54048fa79458f37087591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7963a9de5d516629cde4ca1d3bec0960"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a7963a9de5d516629cde4ca1d3bec0960">ToBigEndian</a> (volatile float64 &amp;x)</td></tr>
<tr class="memdesc:a7963a9de5d516629cde4ca1d3bec0960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a number (float64) from the target operating system endianity to big endian.  <a href="namespaceMARTe_1_1Endianity.html#a7963a9de5d516629cde4ca1d3bec0960">More...</a><br /></td></tr>
<tr class="separator:a7963a9de5d516629cde4ca1d3bec0960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4d13759418d6801f43fe16de90e4e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a4d4d13759418d6801f43fe16de90e4e8">ToBigEndian</a> (volatile float32 &amp;x)</td></tr>
<tr class="memdesc:a4d4d13759418d6801f43fe16de90e4e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a number (float32) from the target operating system endianity to big endian.  <a href="namespaceMARTe_1_1Endianity.html#a4d4d13759418d6801f43fe16de90e4e8">More...</a><br /></td></tr>
<tr class="separator:a4d4d13759418d6801f43fe16de90e4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ecc034cc5614cb2802377422119e549"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a9ecc034cc5614cb2802377422119e549">ToBigEndian</a> (volatile uint64 &amp;x)</td></tr>
<tr class="memdesc:a9ecc034cc5614cb2802377422119e549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a number (uint64) from the target operating system endianity to big endian.  <a href="namespaceMARTe_1_1Endianity.html#a9ecc034cc5614cb2802377422119e549">More...</a><br /></td></tr>
<tr class="separator:a9ecc034cc5614cb2802377422119e549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05378308bba78fdfe641b934c0904b5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a05378308bba78fdfe641b934c0904b5b">ToBigEndian</a> (volatile uint32 &amp;x)</td></tr>
<tr class="memdesc:a05378308bba78fdfe641b934c0904b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a number (uint32) from the target operating system endianity to big endian.  <a href="namespaceMARTe_1_1Endianity.html#a05378308bba78fdfe641b934c0904b5b">More...</a><br /></td></tr>
<tr class="separator:a05378308bba78fdfe641b934c0904b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd43fdaa14694929177545a28be54a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a7bd43fdaa14694929177545a28be54a2">ToBigEndian</a> (volatile uint16 &amp;x)</td></tr>
<tr class="memdesc:a7bd43fdaa14694929177545a28be54a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a number (uint16) from the target operating system endianity to big endian.  <a href="namespaceMARTe_1_1Endianity.html#a7bd43fdaa14694929177545a28be54a2">More...</a><br /></td></tr>
<tr class="separator:a7bd43fdaa14694929177545a28be54a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84857b0bf553b004c75f290fbe13e2df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a84857b0bf553b004c75f290fbe13e2df">ToBigEndian</a> (volatile int64 &amp;x)</td></tr>
<tr class="memdesc:a84857b0bf553b004c75f290fbe13e2df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a number (int64) from the target operating system endianity to big endian.  <a href="namespaceMARTe_1_1Endianity.html#a84857b0bf553b004c75f290fbe13e2df">More...</a><br /></td></tr>
<tr class="separator:a84857b0bf553b004c75f290fbe13e2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5768eb924029eccb677bd06126f2666"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#ab5768eb924029eccb677bd06126f2666">ToBigEndian</a> (volatile int32 &amp;x)</td></tr>
<tr class="memdesc:ab5768eb924029eccb677bd06126f2666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a number (int32) from the target operating system endianity to big endian.  <a href="namespaceMARTe_1_1Endianity.html#ab5768eb924029eccb677bd06126f2666">More...</a><br /></td></tr>
<tr class="separator:ab5768eb924029eccb677bd06126f2666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958240e2f66d49a4bd8f7fd6eb3c0b2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a958240e2f66d49a4bd8f7fd6eb3c0b2f">ToBigEndian</a> (volatile int16 &amp;x)</td></tr>
<tr class="memdesc:a958240e2f66d49a4bd8f7fd6eb3c0b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a number (int16) from the target operating system endianity to big endian.  <a href="namespaceMARTe_1_1Endianity.html#a958240e2f66d49a4bd8f7fd6eb3c0b2f">More...</a><br /></td></tr>
<tr class="separator:a958240e2f66d49a4bd8f7fd6eb3c0b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e77c44304376dce8a66eceffce3a42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a93e77c44304376dce8a66eceffce3a42">ToLittleEndian</a> (volatile float64 &amp;x)</td></tr>
<tr class="memdesc:a93e77c44304376dce8a66eceffce3a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a number (float64) from the target operating system endianity to little endian.  <a href="namespaceMARTe_1_1Endianity.html#a93e77c44304376dce8a66eceffce3a42">More...</a><br /></td></tr>
<tr class="separator:a93e77c44304376dce8a66eceffce3a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e0490a7894bf2049ecb668a3503371"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#af6e0490a7894bf2049ecb668a3503371">ToLittleEndian</a> (volatile float32 &amp;x)</td></tr>
<tr class="memdesc:af6e0490a7894bf2049ecb668a3503371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a number (float32) from the target operating system endianity to little endian.  <a href="namespaceMARTe_1_1Endianity.html#af6e0490a7894bf2049ecb668a3503371">More...</a><br /></td></tr>
<tr class="separator:af6e0490a7894bf2049ecb668a3503371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35409b329c170cb2b44918c15b083514"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a35409b329c170cb2b44918c15b083514">ToLittleEndian</a> (volatile uint64 &amp;x)</td></tr>
<tr class="memdesc:a35409b329c170cb2b44918c15b083514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a number (uint64) from the target operating system endianity to little endian.  <a href="namespaceMARTe_1_1Endianity.html#a35409b329c170cb2b44918c15b083514">More...</a><br /></td></tr>
<tr class="separator:a35409b329c170cb2b44918c15b083514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72dcaf228329b8c2a76cd40907b4ab6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#ac72dcaf228329b8c2a76cd40907b4ab6">ToLittleEndian</a> (volatile uint32 &amp;x)</td></tr>
<tr class="memdesc:ac72dcaf228329b8c2a76cd40907b4ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a number (uint32) from the target operating system endianity to little endian.  <a href="namespaceMARTe_1_1Endianity.html#ac72dcaf228329b8c2a76cd40907b4ab6">More...</a><br /></td></tr>
<tr class="separator:ac72dcaf228329b8c2a76cd40907b4ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad2f59a79224fd569e51df471cacf37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a4ad2f59a79224fd569e51df471cacf37">ToLittleEndian</a> (volatile uint16 &amp;x)</td></tr>
<tr class="memdesc:a4ad2f59a79224fd569e51df471cacf37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a number (uint16) from the target operating system endianity to little endian.  <a href="namespaceMARTe_1_1Endianity.html#a4ad2f59a79224fd569e51df471cacf37">More...</a><br /></td></tr>
<tr class="separator:a4ad2f59a79224fd569e51df471cacf37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fd31be6c42e03d46823eacc232cabb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a06fd31be6c42e03d46823eacc232cabb">ToLittleEndian</a> (volatile int64 &amp;x)</td></tr>
<tr class="memdesc:a06fd31be6c42e03d46823eacc232cabb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a number (int64) from the target operating system endianity to little endian.  <a href="namespaceMARTe_1_1Endianity.html#a06fd31be6c42e03d46823eacc232cabb">More...</a><br /></td></tr>
<tr class="separator:a06fd31be6c42e03d46823eacc232cabb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab173950160773649435f99761c152435"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#ab173950160773649435f99761c152435">ToLittleEndian</a> (volatile int32 &amp;x)</td></tr>
<tr class="memdesc:ab173950160773649435f99761c152435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a number (int32) from the target operating system endianity to little endian.  <a href="namespaceMARTe_1_1Endianity.html#ab173950160773649435f99761c152435">More...</a><br /></td></tr>
<tr class="separator:ab173950160773649435f99761c152435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d4d434ad03b3321e5ac19c7e1660cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#ac8d4d434ad03b3321e5ac19c7e1660cc">ToLittleEndian</a> (volatile int16 &amp;x)</td></tr>
<tr class="memdesc:ac8d4d434ad03b3321e5ac19c7e1660cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a number (int16) from the target operating system endianity to little endian.  <a href="namespaceMARTe_1_1Endianity.html#ac8d4d434ad03b3321e5ac19c7e1660cc">More...</a><br /></td></tr>
<tr class="separator:ac8d4d434ad03b3321e5ac19c7e1660cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aad91fee18eca61f1fdda8e59800ba6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a3aad91fee18eca61f1fdda8e59800ba6">MemCopyFromBigEndian</a> (float64 *dest, const float64 *src, uint32 size)</td></tr>
<tr class="memdesc:a3aad91fee18eca61f1fdda8e59800ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a block of memory (float64) and converts from big endian to the target operating system endianity.  <a href="namespaceMARTe_1_1Endianity.html#a3aad91fee18eca61f1fdda8e59800ba6">More...</a><br /></td></tr>
<tr class="separator:a3aad91fee18eca61f1fdda8e59800ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e11a92ac9189aa274b59362803ea3eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a4e11a92ac9189aa274b59362803ea3eb">MemCopyFromBigEndian</a> (uint64 *dest, const uint64 *src, uint32 size)</td></tr>
<tr class="memdesc:a4e11a92ac9189aa274b59362803ea3eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a block of memory (uint64) and converts from big endian to the target operating system endianity.  <a href="namespaceMARTe_1_1Endianity.html#a4e11a92ac9189aa274b59362803ea3eb">More...</a><br /></td></tr>
<tr class="separator:a4e11a92ac9189aa274b59362803ea3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78873aeb00e7c9624640e0af5ebeb6e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a78873aeb00e7c9624640e0af5ebeb6e3">MemCopyFromBigEndian</a> (int64 *dest, const int64 *src, uint32 size)</td></tr>
<tr class="memdesc:a78873aeb00e7c9624640e0af5ebeb6e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a block of memory (int64) and converts from big endian to the target operating system endianity.  <a href="namespaceMARTe_1_1Endianity.html#a78873aeb00e7c9624640e0af5ebeb6e3">More...</a><br /></td></tr>
<tr class="separator:a78873aeb00e7c9624640e0af5ebeb6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1edb0c3c9092154baf98305e07b12720"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a1edb0c3c9092154baf98305e07b12720">MemCopyFromBigEndian</a> (float32 *dest, const float32 *src, uint32 size)</td></tr>
<tr class="memdesc:a1edb0c3c9092154baf98305e07b12720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a block of memory (float32) and converts from big endian to the target operating system endianity.  <a href="namespaceMARTe_1_1Endianity.html#a1edb0c3c9092154baf98305e07b12720">More...</a><br /></td></tr>
<tr class="separator:a1edb0c3c9092154baf98305e07b12720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54181abf45f34af35766b34746790e0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a54181abf45f34af35766b34746790e0b">MemCopyFromBigEndian</a> (uint32 *dest, const uint32 *src, uint32 size)</td></tr>
<tr class="memdesc:a54181abf45f34af35766b34746790e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a block of memory (uint32) and converts from big endian to the target operating system endianity.  <a href="namespaceMARTe_1_1Endianity.html#a54181abf45f34af35766b34746790e0b">More...</a><br /></td></tr>
<tr class="separator:a54181abf45f34af35766b34746790e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f93d6d12b5748b0f6d284d7f57c45c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a80f93d6d12b5748b0f6d284d7f57c45c">MemCopyFromBigEndian</a> (uint16 *dest, const uint16 *src, uint32 size)</td></tr>
<tr class="memdesc:a80f93d6d12b5748b0f6d284d7f57c45c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a block of memory (uint16) and converts from big endian to the target operating system endianity.  <a href="namespaceMARTe_1_1Endianity.html#a80f93d6d12b5748b0f6d284d7f57c45c">More...</a><br /></td></tr>
<tr class="separator:a80f93d6d12b5748b0f6d284d7f57c45c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e392f99b4016cb911003f79b165e45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a78e392f99b4016cb911003f79b165e45">MemCopyFromBigEndian</a> (int32 *dest, const int32 *src, uint32 size)</td></tr>
<tr class="memdesc:a78e392f99b4016cb911003f79b165e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a block of memory (int32) and converts from big endian to the target operating system endianity.  <a href="namespaceMARTe_1_1Endianity.html#a78e392f99b4016cb911003f79b165e45">More...</a><br /></td></tr>
<tr class="separator:a78e392f99b4016cb911003f79b165e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90b5ecfdef2bb91f690d43b7012febb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#ae90b5ecfdef2bb91f690d43b7012febb">MemCopyFromBigEndian</a> (int16 *dest, const int16 *src, uint32 size)</td></tr>
<tr class="memdesc:ae90b5ecfdef2bb91f690d43b7012febb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a block of memory (int16) and converts from big endian to the target operating system endianity.  <a href="namespaceMARTe_1_1Endianity.html#ae90b5ecfdef2bb91f690d43b7012febb">More...</a><br /></td></tr>
<tr class="separator:ae90b5ecfdef2bb91f690d43b7012febb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa29b7facfc9b7e5ad0c0a929d8c9ef4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#aa29b7facfc9b7e5ad0c0a929d8c9ef4e">MemCopyFromLittleEndian</a> (float64 *dest, const float64 *src, uint32 size)</td></tr>
<tr class="memdesc:aa29b7facfc9b7e5ad0c0a929d8c9ef4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a block of memory (float64) and converts from little endian to the target operating system endianity.  <a href="namespaceMARTe_1_1Endianity.html#aa29b7facfc9b7e5ad0c0a929d8c9ef4e">More...</a><br /></td></tr>
<tr class="separator:aa29b7facfc9b7e5ad0c0a929d8c9ef4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a758738426a961040bef3a2cd108c82d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a758738426a961040bef3a2cd108c82d3">MemCopyFromLittleEndian</a> (uint64 *dest, const uint64 *src, uint32 size)</td></tr>
<tr class="memdesc:a758738426a961040bef3a2cd108c82d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a block of memory (uint64) and converts from little endian to the target operating system endianity.  <a href="namespaceMARTe_1_1Endianity.html#a758738426a961040bef3a2cd108c82d3">More...</a><br /></td></tr>
<tr class="separator:a758738426a961040bef3a2cd108c82d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987b872d8773b84c49a8a9c7fcbde1c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a987b872d8773b84c49a8a9c7fcbde1c1">MemCopyFromLittleEndian</a> (int64 *dest, const int64 *src, uint32 size)</td></tr>
<tr class="memdesc:a987b872d8773b84c49a8a9c7fcbde1c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a block of memory (int64) and converts from little endian to the target operating system endianity.  <a href="namespaceMARTe_1_1Endianity.html#a987b872d8773b84c49a8a9c7fcbde1c1">More...</a><br /></td></tr>
<tr class="separator:a987b872d8773b84c49a8a9c7fcbde1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c697b2b36460a8f05f0cc3c2dfa5ffd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a0c697b2b36460a8f05f0cc3c2dfa5ffd">MemCopyFromLittleEndian</a> (float32 *dest, const float32 *src, uint32 size)</td></tr>
<tr class="memdesc:a0c697b2b36460a8f05f0cc3c2dfa5ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a block of memory (float32) and converts from little endian to the target operating system endianity.  <a href="namespaceMARTe_1_1Endianity.html#a0c697b2b36460a8f05f0cc3c2dfa5ffd">More...</a><br /></td></tr>
<tr class="separator:a0c697b2b36460a8f05f0cc3c2dfa5ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1346c0c60e5385e6eac45d4876aec3f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a1346c0c60e5385e6eac45d4876aec3f4">MemCopyFromLittleEndian</a> (uint32 *dest, const uint32 *src, uint32 size)</td></tr>
<tr class="memdesc:a1346c0c60e5385e6eac45d4876aec3f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a block of memory (uint32) and converts from little endian to the target operating system endianity.  <a href="namespaceMARTe_1_1Endianity.html#a1346c0c60e5385e6eac45d4876aec3f4">More...</a><br /></td></tr>
<tr class="separator:a1346c0c60e5385e6eac45d4876aec3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74663fecc62f426eec40018c6e8457e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a74663fecc62f426eec40018c6e8457e3">MemCopyFromLittleEndian</a> (uint16 *dest, const uint16 *src, uint32 size)</td></tr>
<tr class="memdesc:a74663fecc62f426eec40018c6e8457e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a block of memory (uint16) and converts from little endian to the target operating system endianity.  <a href="namespaceMARTe_1_1Endianity.html#a74663fecc62f426eec40018c6e8457e3">More...</a><br /></td></tr>
<tr class="separator:a74663fecc62f426eec40018c6e8457e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d4444da3d4d18a48feeb942b9ac914"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#ab2d4444da3d4d18a48feeb942b9ac914">MemCopyFromLittleEndian</a> (int32 *dest, const int32 *src, uint32 size)</td></tr>
<tr class="memdesc:ab2d4444da3d4d18a48feeb942b9ac914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a block of memory (int32) and converts from little endian to the target operating system endianity.  <a href="namespaceMARTe_1_1Endianity.html#ab2d4444da3d4d18a48feeb942b9ac914">More...</a><br /></td></tr>
<tr class="separator:ab2d4444da3d4d18a48feeb942b9ac914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8424b2e46f17fb0b9bf94d2c335c958d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a8424b2e46f17fb0b9bf94d2c335c958d">MemCopyFromLittleEndian</a> (int16 *dest, const int16 *src, uint32 size)</td></tr>
<tr class="memdesc:a8424b2e46f17fb0b9bf94d2c335c958d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a block of memory (int16) and converts from little endian to the target operating system endianity.  <a href="namespaceMARTe_1_1Endianity.html#a8424b2e46f17fb0b9bf94d2c335c958d">More...</a><br /></td></tr>
<tr class="separator:a8424b2e46f17fb0b9bf94d2c335c958d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02957353523325f5667a6c55ccfe52bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a02957353523325f5667a6c55ccfe52bc">MemCopyToBigEndian</a> (float64 *dest, const float64 *src, uint32 size)</td></tr>
<tr class="memdesc:a02957353523325f5667a6c55ccfe52bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a block of memory (float64) and converts from the target operating system endianity to big endian.  <a href="namespaceMARTe_1_1Endianity.html#a02957353523325f5667a6c55ccfe52bc">More...</a><br /></td></tr>
<tr class="separator:a02957353523325f5667a6c55ccfe52bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a768ab7ff0c896d5243648410dd0395b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a768ab7ff0c896d5243648410dd0395b1">MemCopyToBigEndian</a> (uint64 *dest, const uint64 *src, uint32 size)</td></tr>
<tr class="memdesc:a768ab7ff0c896d5243648410dd0395b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a block of memory (uint64) and converts from the target operating system endianity to big endian.  <a href="namespaceMARTe_1_1Endianity.html#a768ab7ff0c896d5243648410dd0395b1">More...</a><br /></td></tr>
<tr class="separator:a768ab7ff0c896d5243648410dd0395b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641d6df4162f8f31f975ead048ba5753"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a641d6df4162f8f31f975ead048ba5753">MemCopyToBigEndian</a> (int64 *dest, const int64 *src, uint32 size)</td></tr>
<tr class="memdesc:a641d6df4162f8f31f975ead048ba5753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a block of memory (int64) and converts from the target operating system endianity to big endian.  <a href="namespaceMARTe_1_1Endianity.html#a641d6df4162f8f31f975ead048ba5753">More...</a><br /></td></tr>
<tr class="separator:a641d6df4162f8f31f975ead048ba5753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad010eb50c33113b2e25ea6ad19ab1a4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#ad010eb50c33113b2e25ea6ad19ab1a4a">MemCopyToBigEndian</a> (float32 *dest, const float32 *src, uint32 size)</td></tr>
<tr class="memdesc:ad010eb50c33113b2e25ea6ad19ab1a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a block of memory (float32) and converts from the target operating system endianity to big endian.  <a href="namespaceMARTe_1_1Endianity.html#ad010eb50c33113b2e25ea6ad19ab1a4a">More...</a><br /></td></tr>
<tr class="separator:ad010eb50c33113b2e25ea6ad19ab1a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655ee03e6eb8364dde7ba91c594f662d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a655ee03e6eb8364dde7ba91c594f662d">MemCopyToBigEndian</a> (uint32 *dest, const uint32 *src, uint32 size)</td></tr>
<tr class="memdesc:a655ee03e6eb8364dde7ba91c594f662d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a block of memory (uint32) and converts from the target operating system endianity to big endian.  <a href="namespaceMARTe_1_1Endianity.html#a655ee03e6eb8364dde7ba91c594f662d">More...</a><br /></td></tr>
<tr class="separator:a655ee03e6eb8364dde7ba91c594f662d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66941b26a9fa9c4fbae368a7b589e487"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a66941b26a9fa9c4fbae368a7b589e487">MemCopyToBigEndian</a> (uint16 *dest, const uint16 *src, uint32 size)</td></tr>
<tr class="memdesc:a66941b26a9fa9c4fbae368a7b589e487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a block of memory (uint16) and converts from the target operating system endianity to big endian.  <a href="namespaceMARTe_1_1Endianity.html#a66941b26a9fa9c4fbae368a7b589e487">More...</a><br /></td></tr>
<tr class="separator:a66941b26a9fa9c4fbae368a7b589e487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a085cf7b0f9eaf85cefd071cc3ceae62e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a085cf7b0f9eaf85cefd071cc3ceae62e">MemCopyToBigEndian</a> (int32 *dest, const int32 *src, uint32 size)</td></tr>
<tr class="memdesc:a085cf7b0f9eaf85cefd071cc3ceae62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a block of memory (int32) and converts from the target operating system endianity to big endian.  <a href="namespaceMARTe_1_1Endianity.html#a085cf7b0f9eaf85cefd071cc3ceae62e">More...</a><br /></td></tr>
<tr class="separator:a085cf7b0f9eaf85cefd071cc3ceae62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40820e25fac1de2db42c3bdb86b28099"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a40820e25fac1de2db42c3bdb86b28099">MemCopyToBigEndian</a> (int16 *dest, const int16 *src, uint32 size)</td></tr>
<tr class="memdesc:a40820e25fac1de2db42c3bdb86b28099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a block of memory (int16) and converts from the target operating system endianity to big endian.  <a href="namespaceMARTe_1_1Endianity.html#a40820e25fac1de2db42c3bdb86b28099">More...</a><br /></td></tr>
<tr class="separator:a40820e25fac1de2db42c3bdb86b28099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80db482d590ef622ec9c6d99eff6100d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a80db482d590ef622ec9c6d99eff6100d">MemCopyToLittleEndian</a> (float64 *dest, const float64 *src, uint32 size)</td></tr>
<tr class="memdesc:a80db482d590ef622ec9c6d99eff6100d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a block of memory (float64) and converts from the target operating system endianity to little endian.  <a href="namespaceMARTe_1_1Endianity.html#a80db482d590ef622ec9c6d99eff6100d">More...</a><br /></td></tr>
<tr class="separator:a80db482d590ef622ec9c6d99eff6100d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a585ace22917922ad37096dd04d908"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a39a585ace22917922ad37096dd04d908">MemCopyToLittleEndian</a> (uint64 *dest, const uint64 *src, uint32 size)</td></tr>
<tr class="memdesc:a39a585ace22917922ad37096dd04d908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a block of memory (uint64) and converts from the target operating system endianity to little endian.  <a href="namespaceMARTe_1_1Endianity.html#a39a585ace22917922ad37096dd04d908">More...</a><br /></td></tr>
<tr class="separator:a39a585ace22917922ad37096dd04d908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856cb5bb5a16acf384b9ecb3453f189f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a856cb5bb5a16acf384b9ecb3453f189f">MemCopyToLittleEndian</a> (int64 *dest, const int64 *src, uint32 size)</td></tr>
<tr class="memdesc:a856cb5bb5a16acf384b9ecb3453f189f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a block of memory (int64) and converts from the target operating system endianity to little endian.  <a href="namespaceMARTe_1_1Endianity.html#a856cb5bb5a16acf384b9ecb3453f189f">More...</a><br /></td></tr>
<tr class="separator:a856cb5bb5a16acf384b9ecb3453f189f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4fc2c01fe48031061332a7aad83cf26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#af4fc2c01fe48031061332a7aad83cf26">MemCopyToLittleEndian</a> (float32 *dest, const float32 *src, uint32 size)</td></tr>
<tr class="memdesc:af4fc2c01fe48031061332a7aad83cf26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a block of memory (float32) and converts from the target operating system endianity to little endian.  <a href="namespaceMARTe_1_1Endianity.html#af4fc2c01fe48031061332a7aad83cf26">More...</a><br /></td></tr>
<tr class="separator:af4fc2c01fe48031061332a7aad83cf26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca1f8ec12b2747af56f9b65c8cd3c39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a9ca1f8ec12b2747af56f9b65c8cd3c39">MemCopyToLittleEndian</a> (uint32 *dest, const uint32 *src, uint32 size)</td></tr>
<tr class="memdesc:a9ca1f8ec12b2747af56f9b65c8cd3c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a block of memory (uint32) and converts from the target operating system endianity to little endian.  <a href="namespaceMARTe_1_1Endianity.html#a9ca1f8ec12b2747af56f9b65c8cd3c39">More...</a><br /></td></tr>
<tr class="separator:a9ca1f8ec12b2747af56f9b65c8cd3c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b4206d64c5290b204b806f754a2f32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a48b4206d64c5290b204b806f754a2f32">MemCopyToLittleEndian</a> (uint16 *dest, const uint16 *src, uint32 size)</td></tr>
<tr class="memdesc:a48b4206d64c5290b204b806f754a2f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a block of memory (uint16) and converts from the target operating system endianity to little endian.  <a href="namespaceMARTe_1_1Endianity.html#a48b4206d64c5290b204b806f754a2f32">More...</a><br /></td></tr>
<tr class="separator:a48b4206d64c5290b204b806f754a2f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a99c55baf136efef6ad75506b99ef6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a41a99c55baf136efef6ad75506b99ef6">MemCopyToLittleEndian</a> (int32 *dest, const int32 *src, uint32 size)</td></tr>
<tr class="memdesc:a41a99c55baf136efef6ad75506b99ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a block of memory (int32) and converts from the target operating system endianity to little endian.  <a href="namespaceMARTe_1_1Endianity.html#a41a99c55baf136efef6ad75506b99ef6">More...</a><br /></td></tr>
<tr class="separator:a41a99c55baf136efef6ad75506b99ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687862b4a5c0d0f8814bc6341d1e4e12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a687862b4a5c0d0f8814bc6341d1e4e12">MemCopyToLittleEndian</a> (int16 *dest, const int16 *src, uint32 size)</td></tr>
<tr class="memdesc:a687862b4a5c0d0f8814bc6341d1e4e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a block of memory (int16) and converts from the target operating system endianity to little endian.  <a href="namespaceMARTe_1_1Endianity.html#a687862b4a5c0d0f8814bc6341d1e4e12">More...</a><br /></td></tr>
<tr class="separator:a687862b4a5c0d0f8814bc6341d1e4e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a95c04cc0476a1d98450a83474250af8a"><td class="memItemLeft" align="right" valign="top"><a id="a95c04cc0476a1d98450a83474250af8a"></a>
const uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a95c04cc0476a1d98450a83474250af8a">ENDIANITY_LITTLE_ENDIAN</a> = 1u</td></tr>
<tr class="memdesc:a95c04cc0476a1d98450a83474250af8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of little endian. <br /></td></tr>
<tr class="separator:a95c04cc0476a1d98450a83474250af8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b79975b74dc4956ce51758a9feb6143"><td class="memItemLeft" align="right" valign="top"><a id="a4b79975b74dc4956ce51758a9feb6143"></a>
const uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMARTe_1_1Endianity.html#a4b79975b74dc4956ce51758a9feb6143">ENDIANITY_BIG_ENDIAN</a> = 2u</td></tr>
<tr class="memdesc:a4b79975b74dc4956ce51758a9feb6143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of big endian. <br /></td></tr>
<tr class="separator:a4b79975b74dc4956ce51758a9feb6143"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace which defines a collection of functions for dealing with endianity, taking into account the endianity of the current architecture. </p>
<p>The functions of this namespace offer 3 kinds of services:</p><ul>
<li>Querying the current target architecture (the one of the machine where the code is being executed)</li>
<li>Converting any basic type to (from) the target architecture, from (to) the requested endianity.</li>
<li>Copying blocks of memory with endianity conversion to (from) the target architecture, from (to) the requested endianity.</li>
</ul>
<p>These methods are particularly useful in the implementation of functionality that requires the exchange of data with external producers that might have a different endianity. Examples are drivers and network interfaces.</p>
<p>The target architecture is the one of the machine where the code is being executed. Most of the implementation is therefore delegated to a version which will be specific for each type of supported architecture. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a5a058cb32699e9abaa33936c2d204f5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a058cb32699e9abaa33936c2d204f5a">&#9670;&nbsp;</a></span>FromBigEndian() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::FromBigEndian </td>
          <td>(</td>
          <td class="paramtype">volatile float32 &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a number (float32) from big endian to the target operating system endianity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>the number to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1835da2a8a1ad0fb39a6ad871f5c2948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1835da2a8a1ad0fb39a6ad871f5c2948">&#9670;&nbsp;</a></span>FromBigEndian() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::FromBigEndian </td>
          <td>(</td>
          <td class="paramtype">volatile float64 &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a number (float64) from big endian to the target operating system endianity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>the number to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e4882fb19e136d5d23ff09507fbb1e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e4882fb19e136d5d23ff09507fbb1e3">&#9670;&nbsp;</a></span>FromBigEndian() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::FromBigEndian </td>
          <td>(</td>
          <td class="paramtype">volatile int16 &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a number (int16) from big endian to the target operating system endianity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>the number to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56e6d0d3ce93d8759742c020e2cfab2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56e6d0d3ce93d8759742c020e2cfab2e">&#9670;&nbsp;</a></span>FromBigEndian() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::FromBigEndian </td>
          <td>(</td>
          <td class="paramtype">volatile int32 &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a number (int32) from big endian to the target operating system endianity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>the number to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2f897a624996701ef1dc1db22a12dc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2f897a624996701ef1dc1db22a12dc0">&#9670;&nbsp;</a></span>FromBigEndian() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::FromBigEndian </td>
          <td>(</td>
          <td class="paramtype">volatile int64 &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a number (int64) from big endian to the target operating system endianity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>the number to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1266511817252390c335ca754e75ff65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1266511817252390c335ca754e75ff65">&#9670;&nbsp;</a></span>FromBigEndian() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::FromBigEndian </td>
          <td>(</td>
          <td class="paramtype">volatile uint16 &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a number (uint16) from big endian to the target operating system endianity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>the number to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41bbb89bfee6b762f610cad4e94472a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41bbb89bfee6b762f610cad4e94472a4">&#9670;&nbsp;</a></span>FromBigEndian() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::FromBigEndian </td>
          <td>(</td>
          <td class="paramtype">volatile uint32 &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a number (uint32) from big endian to the target operating system endianity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>the number to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0538f8604b9358f1b81a952151498fe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0538f8604b9358f1b81a952151498fe4">&#9670;&nbsp;</a></span>FromBigEndian() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::FromBigEndian </td>
          <td>(</td>
          <td class="paramtype">volatile uint64 &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a number (uint64) from big endian to the target operating system endianity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>the number to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ccc26c0f66b834cd5beedba32287239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ccc26c0f66b834cd5beedba32287239">&#9670;&nbsp;</a></span>FromLittleEndian() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::FromLittleEndian </td>
          <td>(</td>
          <td class="paramtype">volatile float32 &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a number (float32) from little endian to the target operating system endianity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>the number to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d3854424f7622093eeb179c3f3d08ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d3854424f7622093eeb179c3f3d08ad">&#9670;&nbsp;</a></span>FromLittleEndian() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::FromLittleEndian </td>
          <td>(</td>
          <td class="paramtype">volatile float64 &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a number (float64) from little endian to the target operating system endianity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>the number to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a300e8ada11a54048fa79458f37087591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a300e8ada11a54048fa79458f37087591">&#9670;&nbsp;</a></span>FromLittleEndian() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::FromLittleEndian </td>
          <td>(</td>
          <td class="paramtype">volatile int16 &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a number (int16) from little endian to the target operating system endianity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>the number to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65cb21d4c55be2904a9a833c1ff9eed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65cb21d4c55be2904a9a833c1ff9eed3">&#9670;&nbsp;</a></span>FromLittleEndian() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::FromLittleEndian </td>
          <td>(</td>
          <td class="paramtype">volatile int32 &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a number (int32) from little endian to the target operating system endianity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>the number to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b654ac0250e1e71c808c8fcc0a98c73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b654ac0250e1e71c808c8fcc0a98c73">&#9670;&nbsp;</a></span>FromLittleEndian() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::FromLittleEndian </td>
          <td>(</td>
          <td class="paramtype">volatile int64 &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a number (int64) from little endian to the target operating system endianity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>the number to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3fb678f27ceea0be1869b53242c076a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3fb678f27ceea0be1869b53242c076a">&#9670;&nbsp;</a></span>FromLittleEndian() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::FromLittleEndian </td>
          <td>(</td>
          <td class="paramtype">volatile uint16 &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a number (uint16) from little endian to the target operating system endianity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>the number to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a23553e472227cade18963bdccca4e034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23553e472227cade18963bdccca4e034">&#9670;&nbsp;</a></span>FromLittleEndian() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::FromLittleEndian </td>
          <td>(</td>
          <td class="paramtype">volatile uint32 &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a number (uint32) from little endian to the target operating system endianity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>the number to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98109ea727f5afd0c81aa5984b575d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98109ea727f5afd0c81aa5984b575d68">&#9670;&nbsp;</a></span>FromLittleEndian() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::FromLittleEndian </td>
          <td>(</td>
          <td class="paramtype">volatile uint64 &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a number (uint64) from little endian to the target operating system endianity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>the number to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1edb0c3c9092154baf98305e07b12720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1edb0c3c9092154baf98305e07b12720">&#9670;&nbsp;</a></span>MemCopyFromBigEndian() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::MemCopyFromBigEndian </td>
          <td>(</td>
          <td class="paramtype">float32 *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float32 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a block of memory (float32) and converts from big endian to the target operating system endianity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the source </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>src != NULL &amp;&amp; size &gt;= 0. </dd></dl>

</div>
</div>
<a id="a3aad91fee18eca61f1fdda8e59800ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aad91fee18eca61f1fdda8e59800ba6">&#9670;&nbsp;</a></span>MemCopyFromBigEndian() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::MemCopyFromBigEndian </td>
          <td>(</td>
          <td class="paramtype">float64 *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float64 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a block of memory (float64) and converts from big endian to the target operating system endianity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the source </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>src != NULL &amp;&amp; size &gt;= 0. </dd></dl>

</div>
</div>
<a id="ae90b5ecfdef2bb91f690d43b7012febb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae90b5ecfdef2bb91f690d43b7012febb">&#9670;&nbsp;</a></span>MemCopyFromBigEndian() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::MemCopyFromBigEndian </td>
          <td>(</td>
          <td class="paramtype">int16 *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int16 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a block of memory (int16) and converts from big endian to the target operating system endianity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the source </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>src != NULL &amp;&amp; size &gt;= 0. </dd></dl>

</div>
</div>
<a id="a78e392f99b4016cb911003f79b165e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78e392f99b4016cb911003f79b165e45">&#9670;&nbsp;</a></span>MemCopyFromBigEndian() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::MemCopyFromBigEndian </td>
          <td>(</td>
          <td class="paramtype">int32 *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a block of memory (int32) and converts from big endian to the target operating system endianity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the source </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>src != NULL &amp;&amp; size &gt;= 0. </dd></dl>

</div>
</div>
<a id="a78873aeb00e7c9624640e0af5ebeb6e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78873aeb00e7c9624640e0af5ebeb6e3">&#9670;&nbsp;</a></span>MemCopyFromBigEndian() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::MemCopyFromBigEndian </td>
          <td>(</td>
          <td class="paramtype">int64 *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a block of memory (int64) and converts from big endian to the target operating system endianity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the source </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>src != NULL &amp;&amp; size &gt;= 0. </dd></dl>

</div>
</div>
<a id="a80f93d6d12b5748b0f6d284d7f57c45c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80f93d6d12b5748b0f6d284d7f57c45c">&#9670;&nbsp;</a></span>MemCopyFromBigEndian() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::MemCopyFromBigEndian </td>
          <td>(</td>
          <td class="paramtype">uint16 *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a block of memory (uint16) and converts from big endian to the target operating system endianity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the source </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>src != NULL &amp;&amp; size &gt;= 0. </dd></dl>

</div>
</div>
<a id="a54181abf45f34af35766b34746790e0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54181abf45f34af35766b34746790e0b">&#9670;&nbsp;</a></span>MemCopyFromBigEndian() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::MemCopyFromBigEndian </td>
          <td>(</td>
          <td class="paramtype">uint32 *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a block of memory (uint32) and converts from big endian to the target operating system endianity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the source </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>src != NULL &amp;&amp; size &gt;= 0. </dd></dl>

</div>
</div>
<a id="a4e11a92ac9189aa274b59362803ea3eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e11a92ac9189aa274b59362803ea3eb">&#9670;&nbsp;</a></span>MemCopyFromBigEndian() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::MemCopyFromBigEndian </td>
          <td>(</td>
          <td class="paramtype">uint64 *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a block of memory (uint64) and converts from big endian to the target operating system endianity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the source </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>src != NULL &amp;&amp; size &gt;= 0. </dd></dl>

</div>
</div>
<a id="a0c697b2b36460a8f05f0cc3c2dfa5ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c697b2b36460a8f05f0cc3c2dfa5ffd">&#9670;&nbsp;</a></span>MemCopyFromLittleEndian() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::MemCopyFromLittleEndian </td>
          <td>(</td>
          <td class="paramtype">float32 *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float32 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a block of memory (float32) and converts from little endian to the target operating system endianity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the source </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>src != NULL &amp;&amp; size &gt;= 0. </dd></dl>

</div>
</div>
<a id="aa29b7facfc9b7e5ad0c0a929d8c9ef4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa29b7facfc9b7e5ad0c0a929d8c9ef4e">&#9670;&nbsp;</a></span>MemCopyFromLittleEndian() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::MemCopyFromLittleEndian </td>
          <td>(</td>
          <td class="paramtype">float64 *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float64 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a block of memory (float64) and converts from little endian to the target operating system endianity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the source </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>src != NULL &amp;&amp; size &gt;= 0. </dd></dl>

</div>
</div>
<a id="a8424b2e46f17fb0b9bf94d2c335c958d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8424b2e46f17fb0b9bf94d2c335c958d">&#9670;&nbsp;</a></span>MemCopyFromLittleEndian() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::MemCopyFromLittleEndian </td>
          <td>(</td>
          <td class="paramtype">int16 *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int16 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a block of memory (int16) and converts from little endian to the target operating system endianity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the source </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>src != NULL &amp;&amp; size &gt;= 0. </dd></dl>

</div>
</div>
<a id="ab2d4444da3d4d18a48feeb942b9ac914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2d4444da3d4d18a48feeb942b9ac914">&#9670;&nbsp;</a></span>MemCopyFromLittleEndian() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::MemCopyFromLittleEndian </td>
          <td>(</td>
          <td class="paramtype">int32 *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a block of memory (int32) and converts from little endian to the target operating system endianity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the source </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>src != NULL &amp;&amp; size &gt;= 0. </dd></dl>

</div>
</div>
<a id="a987b872d8773b84c49a8a9c7fcbde1c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a987b872d8773b84c49a8a9c7fcbde1c1">&#9670;&nbsp;</a></span>MemCopyFromLittleEndian() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::MemCopyFromLittleEndian </td>
          <td>(</td>
          <td class="paramtype">int64 *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a block of memory (int64) and converts from little endian to the target operating system endianity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the source </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>src != NULL &amp;&amp; size &gt;= 0. </dd></dl>

</div>
</div>
<a id="a74663fecc62f426eec40018c6e8457e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74663fecc62f426eec40018c6e8457e3">&#9670;&nbsp;</a></span>MemCopyFromLittleEndian() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::MemCopyFromLittleEndian </td>
          <td>(</td>
          <td class="paramtype">uint16 *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a block of memory (uint16) and converts from little endian to the target operating system endianity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the source </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>src != NULL &amp;&amp; size &gt;= 0. </dd></dl>

</div>
</div>
<a id="a1346c0c60e5385e6eac45d4876aec3f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1346c0c60e5385e6eac45d4876aec3f4">&#9670;&nbsp;</a></span>MemCopyFromLittleEndian() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::MemCopyFromLittleEndian </td>
          <td>(</td>
          <td class="paramtype">uint32 *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a block of memory (uint32) and converts from little endian to the target operating system endianity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the source </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>src != NULL &amp;&amp; size &gt;= 0. </dd></dl>

</div>
</div>
<a id="a758738426a961040bef3a2cd108c82d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a758738426a961040bef3a2cd108c82d3">&#9670;&nbsp;</a></span>MemCopyFromLittleEndian() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::MemCopyFromLittleEndian </td>
          <td>(</td>
          <td class="paramtype">uint64 *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a block of memory (uint64) and converts from little endian to the target operating system endianity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the source </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>src != NULL &amp;&amp; size &gt;= 0. </dd></dl>

</div>
</div>
<a id="ad010eb50c33113b2e25ea6ad19ab1a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad010eb50c33113b2e25ea6ad19ab1a4a">&#9670;&nbsp;</a></span>MemCopyToBigEndian() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::MemCopyToBigEndian </td>
          <td>(</td>
          <td class="paramtype">float32 *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float32 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a block of memory (float32) and converts from the target operating system endianity to big endian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the source </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>src != NULL &amp;&amp; size &gt;= 0. </dd></dl>

</div>
</div>
<a id="a02957353523325f5667a6c55ccfe52bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02957353523325f5667a6c55ccfe52bc">&#9670;&nbsp;</a></span>MemCopyToBigEndian() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::MemCopyToBigEndian </td>
          <td>(</td>
          <td class="paramtype">float64 *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float64 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a block of memory (float64) and converts from the target operating system endianity to big endian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the source </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>src != NULL &amp;&amp; size &gt;= 0. </dd></dl>

</div>
</div>
<a id="a40820e25fac1de2db42c3bdb86b28099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40820e25fac1de2db42c3bdb86b28099">&#9670;&nbsp;</a></span>MemCopyToBigEndian() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::MemCopyToBigEndian </td>
          <td>(</td>
          <td class="paramtype">int16 *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int16 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a block of memory (int16) and converts from the target operating system endianity to big endian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the source </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>src != NULL &amp;&amp; size &gt;= 0. </dd></dl>

</div>
</div>
<a id="a085cf7b0f9eaf85cefd071cc3ceae62e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a085cf7b0f9eaf85cefd071cc3ceae62e">&#9670;&nbsp;</a></span>MemCopyToBigEndian() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::MemCopyToBigEndian </td>
          <td>(</td>
          <td class="paramtype">int32 *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a block of memory (int32) and converts from the target operating system endianity to big endian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the source </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>src != NULL &amp;&amp; size &gt;= 0. </dd></dl>

</div>
</div>
<a id="a641d6df4162f8f31f975ead048ba5753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a641d6df4162f8f31f975ead048ba5753">&#9670;&nbsp;</a></span>MemCopyToBigEndian() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::MemCopyToBigEndian </td>
          <td>(</td>
          <td class="paramtype">int64 *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a block of memory (int64) and converts from the target operating system endianity to big endian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the source </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>src != NULL &amp;&amp; size &gt;= 0. </dd></dl>

</div>
</div>
<a id="a66941b26a9fa9c4fbae368a7b589e487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66941b26a9fa9c4fbae368a7b589e487">&#9670;&nbsp;</a></span>MemCopyToBigEndian() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::MemCopyToBigEndian </td>
          <td>(</td>
          <td class="paramtype">uint16 *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a block of memory (uint16) and converts from the target operating system endianity to big endian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the source </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>src != NULL &amp;&amp; size &gt;= 0. </dd></dl>

</div>
</div>
<a id="a655ee03e6eb8364dde7ba91c594f662d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655ee03e6eb8364dde7ba91c594f662d">&#9670;&nbsp;</a></span>MemCopyToBigEndian() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::MemCopyToBigEndian </td>
          <td>(</td>
          <td class="paramtype">uint32 *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a block of memory (uint32) and converts from the target operating system endianity to big endian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the source </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>src != NULL &amp;&amp; size &gt;= 0. </dd></dl>

</div>
</div>
<a id="a768ab7ff0c896d5243648410dd0395b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a768ab7ff0c896d5243648410dd0395b1">&#9670;&nbsp;</a></span>MemCopyToBigEndian() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::MemCopyToBigEndian </td>
          <td>(</td>
          <td class="paramtype">uint64 *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a block of memory (uint64) and converts from the target operating system endianity to big endian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the source </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>src != NULL &amp;&amp; size &gt;= 0. </dd></dl>

</div>
</div>
<a id="af4fc2c01fe48031061332a7aad83cf26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4fc2c01fe48031061332a7aad83cf26">&#9670;&nbsp;</a></span>MemCopyToLittleEndian() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::MemCopyToLittleEndian </td>
          <td>(</td>
          <td class="paramtype">float32 *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float32 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a block of memory (float32) and converts from the target operating system endianity to little endian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the source </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>src != NULL &amp;&amp; size &gt;= 0. </dd></dl>

</div>
</div>
<a id="a80db482d590ef622ec9c6d99eff6100d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80db482d590ef622ec9c6d99eff6100d">&#9670;&nbsp;</a></span>MemCopyToLittleEndian() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::MemCopyToLittleEndian </td>
          <td>(</td>
          <td class="paramtype">float64 *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float64 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a block of memory (float64) and converts from the target operating system endianity to little endian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the source </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>src != NULL &amp;&amp; size &gt;= 0. </dd></dl>

</div>
</div>
<a id="a687862b4a5c0d0f8814bc6341d1e4e12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a687862b4a5c0d0f8814bc6341d1e4e12">&#9670;&nbsp;</a></span>MemCopyToLittleEndian() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::MemCopyToLittleEndian </td>
          <td>(</td>
          <td class="paramtype">int16 *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int16 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a block of memory (int16) and converts from the target operating system endianity to little endian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the source </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>src != NULL &amp;&amp; size &gt;= 0. </dd></dl>

</div>
</div>
<a id="a41a99c55baf136efef6ad75506b99ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41a99c55baf136efef6ad75506b99ef6">&#9670;&nbsp;</a></span>MemCopyToLittleEndian() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::MemCopyToLittleEndian </td>
          <td>(</td>
          <td class="paramtype">int32 *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a block of memory (int32) and converts from the target operating system endianity to little endian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the source </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>src != NULL &amp;&amp; size &gt;= 0. </dd></dl>

</div>
</div>
<a id="a856cb5bb5a16acf384b9ecb3453f189f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a856cb5bb5a16acf384b9ecb3453f189f">&#9670;&nbsp;</a></span>MemCopyToLittleEndian() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::MemCopyToLittleEndian </td>
          <td>(</td>
          <td class="paramtype">int64 *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a block of memory (int64) and converts from the target operating system endianity to little endian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the source </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>src != NULL &amp;&amp; size &gt;= 0. </dd></dl>

</div>
</div>
<a id="a48b4206d64c5290b204b806f754a2f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b4206d64c5290b204b806f754a2f32">&#9670;&nbsp;</a></span>MemCopyToLittleEndian() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::MemCopyToLittleEndian </td>
          <td>(</td>
          <td class="paramtype">uint16 *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a block of memory (uint16) and converts from the target operating system endianity to little endian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the source </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>src != NULL &amp;&amp; size &gt;= 0. </dd></dl>

</div>
</div>
<a id="a9ca1f8ec12b2747af56f9b65c8cd3c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ca1f8ec12b2747af56f9b65c8cd3c39">&#9670;&nbsp;</a></span>MemCopyToLittleEndian() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::MemCopyToLittleEndian </td>
          <td>(</td>
          <td class="paramtype">uint32 *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a block of memory (uint32) and converts from the target operating system endianity to little endian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the source </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>src != NULL &amp;&amp; size &gt;= 0. </dd></dl>

</div>
</div>
<a id="a39a585ace22917922ad37096dd04d908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39a585ace22917922ad37096dd04d908">&#9670;&nbsp;</a></span>MemCopyToLittleEndian() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::MemCopyToLittleEndian </td>
          <td>(</td>
          <td class="paramtype">uint64 *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a block of memory (uint64) and converts from the target operating system endianity to little endian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the source </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>src != NULL &amp;&amp; size &gt;= 0. </dd></dl>

</div>
</div>
<a id="a4d4d13759418d6801f43fe16de90e4e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d4d13759418d6801f43fe16de90e4e8">&#9670;&nbsp;</a></span>ToBigEndian() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::ToBigEndian </td>
          <td>(</td>
          <td class="paramtype">volatile float32 &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a number (float32) from the target operating system endianity to big endian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>the number to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7963a9de5d516629cde4ca1d3bec0960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7963a9de5d516629cde4ca1d3bec0960">&#9670;&nbsp;</a></span>ToBigEndian() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::ToBigEndian </td>
          <td>(</td>
          <td class="paramtype">volatile float64 &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a number (float64) from the target operating system endianity to big endian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>the number to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a958240e2f66d49a4bd8f7fd6eb3c0b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a958240e2f66d49a4bd8f7fd6eb3c0b2f">&#9670;&nbsp;</a></span>ToBigEndian() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::ToBigEndian </td>
          <td>(</td>
          <td class="paramtype">volatile int16 &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a number (int16) from the target operating system endianity to big endian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>the number to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5768eb924029eccb677bd06126f2666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5768eb924029eccb677bd06126f2666">&#9670;&nbsp;</a></span>ToBigEndian() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::ToBigEndian </td>
          <td>(</td>
          <td class="paramtype">volatile int32 &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a number (int32) from the target operating system endianity to big endian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>the number to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a84857b0bf553b004c75f290fbe13e2df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84857b0bf553b004c75f290fbe13e2df">&#9670;&nbsp;</a></span>ToBigEndian() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::ToBigEndian </td>
          <td>(</td>
          <td class="paramtype">volatile int64 &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a number (int64) from the target operating system endianity to big endian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>the number to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7bd43fdaa14694929177545a28be54a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bd43fdaa14694929177545a28be54a2">&#9670;&nbsp;</a></span>ToBigEndian() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::ToBigEndian </td>
          <td>(</td>
          <td class="paramtype">volatile uint16 &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a number (uint16) from the target operating system endianity to big endian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>the number to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05378308bba78fdfe641b934c0904b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05378308bba78fdfe641b934c0904b5b">&#9670;&nbsp;</a></span>ToBigEndian() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::ToBigEndian </td>
          <td>(</td>
          <td class="paramtype">volatile uint32 &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a number (uint32) from the target operating system endianity to big endian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>the number to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ecc034cc5614cb2802377422119e549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ecc034cc5614cb2802377422119e549">&#9670;&nbsp;</a></span>ToBigEndian() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::ToBigEndian </td>
          <td>(</td>
          <td class="paramtype">volatile uint64 &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a number (uint64) from the target operating system endianity to big endian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>the number to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6e0490a7894bf2049ecb668a3503371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6e0490a7894bf2049ecb668a3503371">&#9670;&nbsp;</a></span>ToLittleEndian() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::ToLittleEndian </td>
          <td>(</td>
          <td class="paramtype">volatile float32 &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a number (float32) from the target operating system endianity to little endian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>the number to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93e77c44304376dce8a66eceffce3a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e77c44304376dce8a66eceffce3a42">&#9670;&nbsp;</a></span>ToLittleEndian() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::ToLittleEndian </td>
          <td>(</td>
          <td class="paramtype">volatile float64 &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a number (float64) from the target operating system endianity to little endian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>the number to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8d4d434ad03b3321e5ac19c7e1660cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8d4d434ad03b3321e5ac19c7e1660cc">&#9670;&nbsp;</a></span>ToLittleEndian() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::ToLittleEndian </td>
          <td>(</td>
          <td class="paramtype">volatile int16 &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a number (int16) from the target operating system endianity to little endian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>the number to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab173950160773649435f99761c152435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab173950160773649435f99761c152435">&#9670;&nbsp;</a></span>ToLittleEndian() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::ToLittleEndian </td>
          <td>(</td>
          <td class="paramtype">volatile int32 &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a number (int32) from the target operating system endianity to little endian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>the number to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06fd31be6c42e03d46823eacc232cabb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06fd31be6c42e03d46823eacc232cabb">&#9670;&nbsp;</a></span>ToLittleEndian() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::ToLittleEndian </td>
          <td>(</td>
          <td class="paramtype">volatile int64 &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a number (int64) from the target operating system endianity to little endian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>the number to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ad2f59a79224fd569e51df471cacf37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ad2f59a79224fd569e51df471cacf37">&#9670;&nbsp;</a></span>ToLittleEndian() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::ToLittleEndian </td>
          <td>(</td>
          <td class="paramtype">volatile uint16 &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a number (uint16) from the target operating system endianity to little endian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>the number to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac72dcaf228329b8c2a76cd40907b4ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac72dcaf228329b8c2a76cd40907b4ab6">&#9670;&nbsp;</a></span>ToLittleEndian() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::ToLittleEndian </td>
          <td>(</td>
          <td class="paramtype">volatile uint32 &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a number (uint32) from the target operating system endianity to little endian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>the number to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35409b329c170cb2b44918c15b083514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35409b329c170cb2b44918c15b083514">&#9670;&nbsp;</a></span>ToLittleEndian() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::Endianity::ToLittleEndian </td>
          <td>(</td>
          <td class="paramtype">volatile uint64 &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a number (uint64) from the target operating system endianity to little endian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>the number to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a076cea137576f8a24912a7d272375584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a076cea137576f8a24912a7d272375584">&#9670;&nbsp;</a></span>Type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8 MARTe::Endianity::Type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks the target (i.e. </p>
<p>of where the code is being executed) architecture endianity. </p><dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespaceMARTe_1_1Endianity.html#a95c04cc0476a1d98450a83474250af8a" title="Definition of little endian.">MARTe::Endianity::ENDIANITY_LITTLE_ENDIAN</a> if the target architecture is little endian. <a class="el" href="namespaceMARTe_1_1Endianity.html#a4b79975b74dc4956ce51758a9feb6143" title="Definition of big endian.">MARTe::Endianity::ENDIANITY_BIG_ENDIAN</a> if the target architecture is big endian. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.0
</small></address>
</body>
</html>
