<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MARTe2-components: MARTe::MemoryGate Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MARTe2-components
   </div>
   <div id="projectbrief">C++ real-time application development framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>MARTe</b></li><li class="navelem"><a class="el" href="classMARTe_1_1MemoryGate.html">MemoryGate</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classMARTe_1_1MemoryGate-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MARTe::MemoryGate Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Allows asynchronous communication between any MARTe components.  
 <a href="classMARTe_1_1MemoryGate.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="MemoryGate_8h_source.html">MemoryGate.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MARTe::MemoryGate:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classMARTe_1_1MemoryGate.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a506359f75af77bbb0df3a733421a8849"><td class="memItemLeft" align="right" valign="top"><a id="a506359f75af77bbb0df3a733421a8849"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1MemoryGate.html#a506359f75af77bbb0df3a733421a8849">MemoryGate</a> ()</td></tr>
<tr class="memdesc:a506359f75af77bbb0df3a733421a8849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a506359f75af77bbb0df3a733421a8849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe60c381ecb76c2b2f9cf3f636a2903"><td class="memItemLeft" align="right" valign="top"><a id="a0fe60c381ecb76c2b2f9cf3f636a2903"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1MemoryGate.html#a0fe60c381ecb76c2b2f9cf3f636a2903">~MemoryGate</a> ()</td></tr>
<tr class="memdesc:a0fe60c381ecb76c2b2f9cf3f636a2903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a0fe60c381ecb76c2b2f9cf3f636a2903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27cee8e01ae535f52c6afbc7030cdd50"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1MemoryGate.html#a27cee8e01ae535f52c6afbc7030cdd50">Initialise</a> (StructuredDataI &amp;data)</td></tr>
<tr class="separator:a27cee8e01ae535f52c6afbc7030cdd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f5f94dfba4f7aa6e765a42ee7cbe77b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1MemoryGate.html#a6f5f94dfba4f7aa6e765a42ee7cbe77b">SetMemorySize</a> (uint32 size)</td></tr>
<tr class="memdesc:a6f5f94dfba4f7aa6e765a42ee7cbe77b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <em>size</em> in input is equal to the previous declared buffer size.  <a href="classMARTe_1_1MemoryGate.html#a6f5f94dfba4f7aa6e765a42ee7cbe77b">More...</a><br /></td></tr>
<tr class="separator:a6f5f94dfba4f7aa6e765a42ee7cbe77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8cd08ba67033441dee95cecd766e6b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1MemoryGate.html#a3a8cd08ba67033441dee95cecd766e6b">MemoryRead</a> (uint8 *const bufferToFill)</td></tr>
<tr class="memdesc:a3a8cd08ba67033441dee95cecd766e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function called by readers.  <a href="classMARTe_1_1MemoryGate.html#a3a8cd08ba67033441dee95cecd766e6b">More...</a><br /></td></tr>
<tr class="separator:a3a8cd08ba67033441dee95cecd766e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2e2746577e6c985a6656ebf9621031"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1MemoryGate.html#a8b2e2746577e6c985a6656ebf9621031">MemoryWrite</a> (const uint8 *const bufferToFlush)</td></tr>
<tr class="memdesc:a8b2e2746577e6c985a6656ebf9621031"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function called by writers.  <a href="classMARTe_1_1MemoryGate.html#a8b2e2746577e6c985a6656ebf9621031">More...</a><br /></td></tr>
<tr class="separator:a8b2e2746577e6c985a6656ebf9621031"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a1f8dcfd3b65dffae0d5c5be1f7f1f7bd"><td class="memItemLeft" align="right" valign="top"><a id="a1f8dcfd3b65dffae0d5c5be1f7f1f7bd"></a>
uint8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1MemoryGate.html#a1f8dcfd3b65dffae0d5c5be1f7f1f7bd">mem</a></td></tr>
<tr class="memdesc:a1f8dcfd3b65dffae0d5c5be1f7f1f7bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total internal memory. <br /></td></tr>
<tr class="separator:a1f8dcfd3b65dffae0d5c5be1f7f1f7bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc22c52d06bf1895a112c2608a31fbd"><td class="memItemLeft" align="right" valign="top"><a id="a0cc22c52d06bf1895a112c2608a31fbd"></a>
uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1MemoryGate.html#a0cc22c52d06bf1895a112c2608a31fbd">memSize</a></td></tr>
<tr class="memdesc:a0cc22c52d06bf1895a112c2608a31fbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of a buffer. <br /></td></tr>
<tr class="separator:a0cc22c52d06bf1895a112c2608a31fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94707282cf858a663bcc9d64129d59ec"><td class="memItemLeft" align="right" valign="top"><a id="a94707282cf858a663bcc9d64129d59ec"></a>
uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1MemoryGate.html#a94707282cf858a663bcc9d64129d59ec">numberOfBuffers</a></td></tr>
<tr class="memdesc:a94707282cf858a663bcc9d64129d59ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of buffers. <br /></td></tr>
<tr class="separator:a94707282cf858a663bcc9d64129d59ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6b9d2f1a9d3306f76e45253ffb4280"><td class="memItemLeft" align="right" valign="top"><a id="a3c6b9d2f1a9d3306f76e45253ffb4280"></a>
volatile int32 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1MemoryGate.html#a3c6b9d2f1a9d3306f76e45253ffb4280">spinlocksRead</a></td></tr>
<tr class="memdesc:a3c6b9d2f1a9d3306f76e45253ffb4280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Denoted the current number of readers for each buffer. <br /></td></tr>
<tr class="separator:a3c6b9d2f1a9d3306f76e45253ffb4280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a792b0bc303924cfc4f3099eb9ff32082"><td class="memItemLeft" align="right" valign="top"><a id="a792b0bc303924cfc4f3099eb9ff32082"></a>
FastPollingMutexSem *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1MemoryGate.html#a792b0bc303924cfc4f3099eb9ff32082">spinlocksWrite</a></td></tr>
<tr class="memdesc:a792b0bc303924cfc4f3099eb9ff32082"><td class="mdescLeft">&#160;</td><td class="mdescRight">A semaphore to lock the buffer that is going to be written. <br /></td></tr>
<tr class="separator:a792b0bc303924cfc4f3099eb9ff32082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3daae2fa38d4656f340ac044e9c97076"><td class="memItemLeft" align="right" valign="top"><a id="a3daae2fa38d4656f340ac044e9c97076"></a>
uint32 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1MemoryGate.html#a3daae2fa38d4656f340ac044e9c97076">whatIsNewestCounter</a></td></tr>
<tr class="memdesc:a3daae2fa38d4656f340ac044e9c97076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to denote the oldest and newest written buffers. <br /></td></tr>
<tr class="separator:a3daae2fa38d4656f340ac044e9c97076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce3e1e7d56abb0889ee975e15b7d393"><td class="memItemLeft" align="right" valign="top"><a id="a0ce3e1e7d56abb0889ee975e15b7d393"></a>
uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1MemoryGate.html#a0ce3e1e7d56abb0889ee975e15b7d393">whatIsNewestGlobCounter</a></td></tr>
<tr class="memdesc:a0ce3e1e7d56abb0889ee975e15b7d393"><td class="mdescLeft">&#160;</td><td class="mdescRight">The counter incremented for each signal at the end of the write operation. <br /></td></tr>
<tr class="separator:a0ce3e1e7d56abb0889ee975e15b7d393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d75621625b6d4e437e9ca73291bd86"><td class="memItemLeft" align="right" valign="top"><a id="a33d75621625b6d4e437e9ca73291bd86"></a>
uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1MemoryGate.html#a33d75621625b6d4e437e9ca73291bd86">offsetStore</a></td></tr>
<tr class="memdesc:a33d75621625b6d4e437e9ca73291bd86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the signal offset in case of more write operations. <br /></td></tr>
<tr class="separator:a33d75621625b6d4e437e9ca73291bd86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b645d0a100a85469758c310455f474"><td class="memItemLeft" align="right" valign="top"><a id="a45b645d0a100a85469758c310455f474"></a>
TimeoutType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1MemoryGate.html#a45b645d0a100a85469758c310455f474">resetTimeout</a></td></tr>
<tr class="memdesc:a45b645d0a100a85469758c310455f474"><td class="mdescLeft">&#160;</td><td class="mdescRight">The timeout in millisecs to lock the other <em>spinlocksWrite</em> semaphores in case of overflow of <em>whatIsNewestCounter</em> (to avoid a priority inversion) <br /></td></tr>
<tr class="separator:a45b645d0a100a85469758c310455f474"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Allows asynchronous communication between any MARTe components. </p>
<p>The user can specify up to 64 buffers of memory by configuration and, optionally, the buffer memory size that must be shared between all the components linked to this object. The function <a class="el" href="classMARTe_1_1MemoryGate.html#a6f5f94dfba4f7aa6e765a42ee7cbe77b" title="Checks if size in input is equal to the previous declared buffer size.">SetMemorySize()</a> should be called from all the linked components to agree the memory size and to instantiate it if it is not declared in the configuration.</p>
<p>The readers call the function <a class="el" href="classMARTe_1_1MemoryGate.html#a3a8cd08ba67033441dee95cecd766e6b" title="The function called by readers.">MemoryRead()</a> that will fill the input buffer with the value of the last written available buffer. If all the buffers are busy by writers, the <a class="el" href="classMARTe_1_1MemoryGate.html#a3a8cd08ba67033441dee95cecd766e6b" title="The function called by readers.">MemoryRead()</a> returns false. Parallel reads on the same buffer are allowed.</p>
<p>The writers call the function <a class="el" href="classMARTe_1_1MemoryGate.html#a8b2e2746577e6c985a6656ebf9621031" title="The function called by writers.">MemoryWrite()</a> that will flush the input buffer to the oldest written available buffer. If all the buffers are busy by readers or other writers, the <a class="el" href="classMARTe_1_1MemoryGate.html#a8b2e2746577e6c985a6656ebf9621031" title="The function called by writers.">MemoryWrite()</a> returns false.</p>
<p>The configuration syntax is (names are only given as an example):</p>
<pre>
   +SharedMem = {
       Class = <a class="el" href="classMARTe_1_1MemoryGate.html" title="Allows asynchronous communication between any MARTe components.">MemoryGate</a>
       NumberOfBuffers = 10 //The number of buffers that should be in [1-64]. Default = 2
       ResetMSecTimeout = 10 //The timeout in milliseconds used by the mutex to lock all the buffers to change the write operations counters in case of write overflow). Default is 0xFFFFFFFF.<br  />
       MemorySize = 100 //The size of each buffer memory. If this parameter is not set or if it is equal to zero and the buffer size will be set by the first component that calls <a class="el" href="classMARTe_1_1MemoryGate.html#a6f5f94dfba4f7aa6e765a42ee7cbe77b" title="Checks if size in input is equal to the previous declared buffer size.">SetMemorySize()</a>.
   }
</pre> </div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a27cee8e01ae535f52c6afbc7030cdd50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27cee8e01ae535f52c6afbc7030cdd50">&#9670;&nbsp;</a></span>Initialise()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::MemoryGate::Initialise </td>
          <td>(</td>
          <td class="paramtype">StructuredDataI &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>ReferenceContainer::Initialise()  The user can specify the following configuration parameters:<br  />
<ul>
<li>NumberOfBuffers = N (the number of buffers that should be in [1-64]. Default = 2)<br  />
</li>
<li>ResetMSecTimeout = N (the timeout in milliseconds used by the mutex to lock all the buffers to change the write operations counters in case of overflow). Default is 0xFFFFFFFF.<br  />
</li>
<li>MemorySize = N (the size of each buffer memory. If this parameter is not set or if it is equal to zero, the buffer size will be set by the first component that calls <a class="el" href="classMARTe_1_1MemoryGate.html#a6f5f94dfba4f7aa6e765a42ee7cbe77b" title="Checks if size in input is equal to the previous declared buffer size.">SetMemorySize()</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a3a8cd08ba67033441dee95cecd766e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a8cd08ba67033441dee95cecd766e6b">&#9670;&nbsp;</a></span>MemoryRead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::MemoryGate::MemoryRead </td>
          <td>(</td>
          <td class="paramtype">uint8 *const&#160;</td>
          <td class="paramname"><em>bufferToFill</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The function called by readers. </p>
<p>Browses the buffers to peek the last written available and copy its value to <em>bufferToFill</em>. If no buffer is available, it returns false. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferToFill</td><td>is the buffer to be filled with read data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if at least one buffer is available, false otherwise. </dd></dl>

</div>
</div>
<a id="a8b2e2746577e6c985a6656ebf9621031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b2e2746577e6c985a6656ebf9621031">&#9670;&nbsp;</a></span>MemoryWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::MemoryGate::MemoryWrite </td>
          <td>(</td>
          <td class="paramtype">const uint8 *const&#160;</td>
          <td class="paramname"><em>bufferToFlush</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The function called by writers. </p>
<p>Browses the buffers to peek the oldest written available one and copy on it the value of <em>bufferToFlush</em>. If no buffer is available, it returns false. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferToFlush</td><td>is the buffer contains the data to be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if at least one buffer is available, false otherwise. </dd></dl>

</div>
</div>
<a id="a6f5f94dfba4f7aa6e765a42ee7cbe77b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f5f94dfba4f7aa6e765a42ee7cbe77b">&#9670;&nbsp;</a></span>SetMemorySize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::MemoryGate::SetMemorySize </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <em>size</em> in input is equal to the previous declared buffer size. </p>
<p>If by configuration the user has not declared the "MemorySize" parameter, or if it has been declared equal to zero, then the first call to this function will set the buffer size and allocates the memory. Successive calls will check if <em>size</em> in input is equal to the size of the allocated buffer memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>is the size of the buffer memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <em>size</em> in input is equal to the previous declared buffer size, false otherwise. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/codac-dev/MARTe2Project/GIT/MARTe2-components/Source/Components/Interfaces/MemoryGate/<a class="el" href="MemoryGate_8h_source.html">MemoryGate.h</a></li>
<li>/home/codac-dev/MARTe2Project/GIT/MARTe2-components/Source/Components/Interfaces/MemoryGate/<a class="el" href="MemoryGate_8cpp.html">MemoryGate.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.0
</small></address>
</body>
</html>
