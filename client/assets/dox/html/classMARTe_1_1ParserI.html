<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>MARTe2-components: MARTe::ParserI Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MARTe2-components
   </div>
   <div id="projectbrief">C++ real-time application development framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceMARTe.html">MARTe</a></li><li class="navelem"><a class="el" href="classMARTe_1_1ParserI.html">ParserI</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classMARTe_1_1ParserI-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MARTe::ParserI Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Abstract parser which allows to transform a stream of characters into a structured data store, applying lexical rules set at instance level and parsing rules implemented into subclasses.  
 <a href="classMARTe_1_1ParserI.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ParserI_8h_source.html">ParserI.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MARTe::ParserI:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classMARTe_1_1ParserI.png" usemap="#MARTe::ParserI_map" alt=""/>
  <map id="MARTe::ParserI_map" name="MARTe::ParserI_map">
<area href="classMARTe_1_1JsonParser.html" title="Concrete class for MARTe::ParserI abstract class, configured for streams of characters encoded in JSO..." alt="MARTe::JsonParser" shape="rect" coords="0,56,149,80"/>
<area href="classMARTe_1_1StandardParser.html" title="Concrete class for MARTe::ParserI abstract class, configured for streams of characters encoded in MAR..." alt="MARTe::StandardParser" shape="rect" coords="159,56,308,80"/>
<area href="classMARTe_1_1XMLParser.html" title="Concrete class for MARTe::ParserI abstract class, configured for streams of characters encoded in XML..." alt="MARTe::XMLParser" shape="rect" coords="318,56,467,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af28ed7116d9251c84991f0563400b844"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1ParserI.html#af28ed7116d9251c84991f0563400b844">ParserI</a> (<a class="el" href="classMARTe_1_1StreamI.html">StreamI</a> &amp;stream, <a class="el" href="classMARTe_1_1StructuredDataI.html">StructuredDataI</a> &amp;databaseIn, <a class="el" href="classMARTe_1_1BufferedStreamI.html">BufferedStreamI</a> *const err, const <a class="el" href="structMARTe_1_1GrammarInfo.html">GrammarInfo</a> &amp;grammarIn)</td></tr>
<tr class="memdesc:af28ed7116d9251c84991f0563400b844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor which initializes the instance with all the items involved into the parsing (input, output, and grammar configuration).  <a href="#af28ed7116d9251c84991f0563400b844">More...</a><br /></td></tr>
<tr class="separator:af28ed7116d9251c84991f0563400b844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed7c391e78a859426cedd8f8c7474b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ed7c391e78a859426cedd8f8c7474b2"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1ParserI.html#a9ed7c391e78a859426cedd8f8c7474b2">~ParserI</a> ()</td></tr>
<tr class="memdesc:a9ed7c391e78a859426cedd8f8c7474b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a9ed7c391e78a859426cedd8f8c7474b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ffe84eef1f75023e100fa1990687fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1ParserI.html#ac0ffe84eef1f75023e100fa1990687fe">Parse</a> ()</td></tr>
<tr class="memdesc:ac0ffe84eef1f75023e100fa1990687fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the stream in input and builds the configuration database accordingly.  <a href="#ac0ffe84eef1f75023e100fa1990687fe">More...</a><br /></td></tr>
<tr class="separator:ac0ffe84eef1f75023e100fa1990687fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda1db7c382c368039efec0c06164423"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMARTe_1_1GrammarInfo.html">GrammarInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1ParserI.html#adda1db7c382c368039efec0c06164423">GetGrammarInfo</a> () const </td></tr>
<tr class="memdesc:adda1db7c382c368039efec0c06164423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the grammar used by this parser.  <a href="#adda1db7c382c368039efec0c06164423">More...</a><br /></td></tr>
<tr class="separator:adda1db7c382c368039efec0c06164423"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a5b1e4a40e6eff5e7802cecdd79e6d215"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b1e4a40e6eff5e7802cecdd79e6d215"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1ParserI.html#a5b1e4a40e6eff5e7802cecdd79e6d215">End</a> ()</td></tr>
<tr class="memdesc:a5b1e4a40e6eff5e7802cecdd79e6d215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves into the built structured data to the root. <br /></td></tr>
<tr class="separator:a5b1e4a40e6eff5e7802cecdd79e6d215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8fc07f8ad3343c3167667f67412637b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8fc07f8ad3343c3167667f67412637b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1ParserI.html#ad8fc07f8ad3343c3167667f67412637b">GetNodeName</a> ()</td></tr>
<tr class="memdesc:ad8fc07f8ad3343c3167667f67412637b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the node or the variable name. <br /></td></tr>
<tr class="separator:ad8fc07f8ad3343c3167667f67412637b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1854955e56ff563da16fbe6c70ca2a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b1854955e56ff563da16fbe6c70ca2a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1ParserI.html#a2b1854955e56ff563da16fbe6c70ca2a">AddLeaf</a> ()</td></tr>
<tr class="memdesc:a2b1854955e56ff563da16fbe6c70ca2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a leaf in the StructuredData. <br /></td></tr>
<tr class="separator:a2b1854955e56ff563da16fbe6c70ca2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2561ca7a01317a034ad5a8a0bbf746eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2561ca7a01317a034ad5a8a0bbf746eb"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1ParserI.html#a2561ca7a01317a034ad5a8a0bbf746eb">GetTypeCast</a> ()</td></tr>
<tr class="memdesc:a2561ca7a01317a034ad5a8a0bbf746eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the variable type. <br /></td></tr>
<tr class="separator:a2561ca7a01317a034ad5a8a0bbf746eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28482a0ef9c9edb0b5137edbd6ea44d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28482a0ef9c9edb0b5137edbd6ea44d2"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1ParserI.html#a28482a0ef9c9edb0b5137edbd6ea44d2">CreateNode</a> ()</td></tr>
<tr class="memdesc:a28482a0ef9c9edb0b5137edbd6ea44d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new node in the StructuredData. <br /></td></tr>
<tr class="separator:a28482a0ef9c9edb0b5137edbd6ea44d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8398b16cc99f8690c5700332d53b0f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e8398b16cc99f8690c5700332d53b0f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1ParserI.html#a8e8398b16cc99f8690c5700332d53b0f">AddScalar</a> ()</td></tr>
<tr class="memdesc:a8e8398b16cc99f8690c5700332d53b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a read scalar in the memory. <br /></td></tr>
<tr class="separator:a8e8398b16cc99f8690c5700332d53b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c026517502948f9bd00ea441490281"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2c026517502948f9bd00ea441490281"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1ParserI.html#ad2c026517502948f9bd00ea441490281">EndVector</a> ()</td></tr>
<tr class="memdesc:ad2c026517502948f9bd00ea441490281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of dimensions to one and checks if the matrix is well formed. <br /></td></tr>
<tr class="separator:ad2c026517502948f9bd00ea441490281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ebf42433926f9656ee58aa28772c5f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81ebf42433926f9656ee58aa28772c5f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1ParserI.html#a81ebf42433926f9656ee58aa28772c5f">EndMatrix</a> ()</td></tr>
<tr class="memdesc:a81ebf42433926f9656ee58aa28772c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of dimensions to two. <br /></td></tr>
<tr class="separator:a81ebf42433926f9656ee58aa28772c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb8c4aee806f75113ebb922cc85177a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0fb8c4aee806f75113ebb922cc85177a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1ParserI.html#a0fb8c4aee806f75113ebb922cc85177a">BlockEnd</a> ()</td></tr>
<tr class="memdesc:a0fb8c4aee806f75113ebb922cc85177a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves into the structuredData to the father. <br /></td></tr>
<tr class="separator:a0fb8c4aee806f75113ebb922cc85177a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24183e78dba324cb652241192315456"><td class="memItemLeft" align="right" valign="top">virtual uint32 &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1ParserI.html#ab24183e78dba324cb652241192315456">GetProduction</a> (const uint32 index) const =0</td></tr>
<tr class="memdesc:ab24183e78dba324cb652241192315456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the next expected token identifiers to be pushed on the stack.  <a href="#ab24183e78dba324cb652241192315456">More...</a><br /></td></tr>
<tr class="separator:ab24183e78dba324cb652241192315456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762832ea01a8ef079c6555195f001deb"><td class="memItemLeft" align="right" valign="top">virtual uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1ParserI.html#a762832ea01a8ef079c6555195f001deb">GetProductionRow</a> (const uint32 index) const =0</td></tr>
<tr class="memdesc:a762832ea01a8ef079c6555195f001deb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the index of the productions array.  <a href="#a762832ea01a8ef079c6555195f001deb">More...</a><br /></td></tr>
<tr class="separator:a762832ea01a8ef079c6555195f001deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dfb7a998e1f8086dbe9df834ea76924"><td class="memItemLeft" align="right" valign="top">virtual uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1ParserI.html#a5dfb7a998e1f8086dbe9df834ea76924">GetParse</a> (const uint32 index) const =0</td></tr>
<tr class="memdesc:a5dfb7a998e1f8086dbe9df834ea76924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the next token identifier.  <a href="#a5dfb7a998e1f8086dbe9df834ea76924">More...</a><br /></td></tr>
<tr class="separator:a5dfb7a998e1f8086dbe9df834ea76924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a57ea9d5ad0cfacbd289467e206075"><td class="memItemLeft" align="right" valign="top">virtual uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1ParserI.html#ac6a57ea9d5ad0cfacbd289467e206075">GetParseRow</a> (const uint32 index) const =0</td></tr>
<tr class="memdesc:ac6a57ea9d5ad0cfacbd289467e206075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the index of the parse array.  <a href="#ac6a57ea9d5ad0cfacbd289467e206075">More...</a><br /></td></tr>
<tr class="separator:ac6a57ea9d5ad0cfacbd289467e206075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5125cf46ff25319f02bf9864f683caa"><td class="memItemLeft" align="right" valign="top">virtual uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1ParserI.html#af5125cf46ff25319f02bf9864f683caa">GetConflict</a> (const uint32 index) const =0</td></tr>
<tr class="memdesc:af5125cf46ff25319f02bf9864f683caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the conflict number.  <a href="#af5125cf46ff25319f02bf9864f683caa">More...</a><br /></td></tr>
<tr class="separator:af5125cf46ff25319f02bf9864f683caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc5c63c6780e1670c9da396c1c9c7ca"><td class="memItemLeft" align="right" valign="top">virtual uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1ParserI.html#a9dc5c63c6780e1670c9da396c1c9c7ca">GetConflictRow</a> (const uint32 index) const =0</td></tr>
<tr class="memdesc:a9dc5c63c6780e1670c9da396c1c9c7ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the conflict array index.  <a href="#a9dc5c63c6780e1670c9da396c1c9c7ca">More...</a><br /></td></tr>
<tr class="separator:a9dc5c63c6780e1670c9da396c1c9c7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a515767fa92042c9b5fd3af9d7ee985f4"><td class="memItemLeft" align="right" valign="top">virtual uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1ParserI.html#a515767fa92042c9b5fd3af9d7ee985f4">GetConstant</a> (const uint32 index) const =0</td></tr>
<tr class="memdesc:a515767fa92042c9b5fd3af9d7ee985f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the constants used by the parser.  <a href="#a515767fa92042c9b5fd3af9d7ee985f4">More...</a><br /></td></tr>
<tr class="separator:a515767fa92042c9b5fd3af9d7ee985f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ad10a50bd2d58c52bdff0d6a196253"><td class="memItemLeft" align="right" valign="top">virtual const char8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1ParserI.html#a87ad10a50bd2d58c52bdff0d6a196253">GetSymbolName</a> (const uint32 symbol) const =0</td></tr>
<tr class="memdesc:a87ad10a50bd2d58c52bdff0d6a196253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the name associated to the token.  <a href="#a87ad10a50bd2d58c52bdff0d6a196253">More...</a><br /></td></tr>
<tr class="separator:a87ad10a50bd2d58c52bdff0d6a196253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4af29e5bb00ac0d938de1ad1c7399a2"><td class="memItemLeft" align="right" valign="top">virtual uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1ParserI.html#af4af29e5bb00ac0d938de1ad1c7399a2">GetNextTokenType</a> ()</td></tr>
<tr class="memdesc:af4af29e5bb00ac0d938de1ad1c7399a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the identifier of the next token produced by the lexical analyzer.  <a href="#af4af29e5bb00ac0d938de1ad1c7399a2">More...</a><br /></td></tr>
<tr class="separator:af4af29e5bb00ac0d938de1ad1c7399a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b66585af5a37a428a7880d1f9280fe8"><td class="memItemLeft" align="right" valign="top">virtual uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1ParserI.html#a2b66585af5a37a428a7880d1f9280fe8">PeekNextTokenType</a> (const uint32 position)</td></tr>
<tr class="memdesc:a2b66585af5a37a428a7880d1f9280fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peeks in the token stack produced by the lexical analyzer, retrieves the identifier of the token in the next <em>position</em> index.  <a href="#a2b66585af5a37a428a7880d1f9280fe8">More...</a><br /></td></tr>
<tr class="separator:a2b66585af5a37a428a7880d1f9280fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5adc64365d04d299ed3e1dd1ba6b8f06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1ParserI.html#a5adc64365d04d299ed3e1dd1ba6b8f06">StackPush</a> (const uint32 symbol, const uint32 *const stack, uint32 *&amp;top) const </td></tr>
<tr class="memdesc:a5adc64365d04d299ed3e1dd1ba6b8f06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes the expected token to the stack.  <a href="#a5adc64365d04d299ed3e1dd1ba6b8f06">More...</a><br /></td></tr>
<tr class="separator:a5adc64365d04d299ed3e1dd1ba6b8f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b895bb96422c68b5b5971839935d35"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1ParserI.html#a86b895bb96422c68b5b5971839935d35">StackPop</a> (uint32 *&amp;top) const </td></tr>
<tr class="memdesc:a86b895bb96422c68b5b5971839935d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pops the expected token from the internal stack.  <a href="#a86b895bb96422c68b5b5971839935d35">More...</a><br /></td></tr>
<tr class="separator:a86b895bb96422c68b5b5971839935d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335e87846d287d3d5b432b03847db009"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1ParserI.html#a335e87846d287d3d5b432b03847db009">Execute</a> (const uint32 number)=0</td></tr>
<tr class="memdesc:a335e87846d287d3d5b432b03847db009"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the specified function.  <a href="#a335e87846d287d3d5b432b03847db009">More...</a><br /></td></tr>
<tr class="separator:a335e87846d287d3d5b432b03847db009"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a299b12982d8756251d0187bc137c8e66"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a299b12982d8756251d0187bc137c8e66"></a>
<a class="el" href="classMARTe_1_1Token.html">Token</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1ParserI.html#a299b12982d8756251d0187bc137c8e66">currentToken</a></td></tr>
<tr class="memdesc:a299b12982d8756251d0187bc137c8e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the last token produced by the lexical analyzer. <br /></td></tr>
<tr class="separator:a299b12982d8756251d0187bc137c8e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Abstract parser which allows to transform a stream of characters into a structured data store, applying lexical rules set at instance level and parsing rules implemented into subclasses. </p>
<p>This class is a partial abstract class providing the generic functionality of a parser while expecting subclasses to provide the specific rules for each concrete language (each subclass must implement the pure abstract functions).</p>
<p>Each instance of the parser is bound when it is constructed, with all the objects involved in the parsing analysis, as follows:</p><ul>
<li>An input stream of characters that contains the serialization of a hierarchy of objects, encoded into a given language (e.g. XML, JSON, etc).</li>
<li>An output structured data store where the parser will build the in- memory objects defined into the input stream of characters.</li>
<li>An output stream of characters where the parser will write all the errors found on the input stream of characters.</li>
</ul>
<p>At construction time, too, the parser is initialized with the lexical elements that the language used in the input stream of characters needs, while the grammar of that language is expected to be implemented in subclasses.</p>
<p>After being properly created, each instance is ready to parse the input stream of characters, whenever the user calls the method <a class="el" href="classMARTe_1_1ParserI.html#ac0ffe84eef1f75023e100fa1990687fe" title="Parses the stream in input and builds the configuration database accordingly. ">Parse()</a>.</p>
<p>Notes about the input stream of characters:</p><ul>
<li>All the elements of a vector or matrix must be of the same token type (NUMBER or STRING).</li>
<li>Variables cannot be empty (i.e "scalar = " or vector = {}" or
"matrix = {{}}").</li>
<li>If the type specified in the TYPE CAST expression is invalid, the value will be saved in the database as a C-string (default), otherwise the token will be converted to the specified type and then saved in the database.</li>
<li>The error messages printed on the <em>err</em> stream are in the format "error description [line number]". </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af28ed7116d9251c84991f0563400b844"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MARTe::ParserI::ParserI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMARTe_1_1StreamI.html">StreamI</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMARTe_1_1StructuredDataI.html">StructuredDataI</a> &amp;&#160;</td>
          <td class="paramname"><em>databaseIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMARTe_1_1BufferedStreamI.html">BufferedStreamI</a> *const&#160;</td>
          <td class="paramname"><em>err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMARTe_1_1GrammarInfo.html">GrammarInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>grammarIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor which initializes the instance with all the items involved into the parsing (input, output, and grammar configuration). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>is the stream to be read and parsed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">databaseIn</td><td>is the StructuredData in output. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>is a stream where parse error messages are written into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">grammarIn</td><td>contains the comments patterns, the separator and terminal characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>GetGrammar() == grammarIn </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a335e87846d287d3d5b432b03847db009"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MARTe::ParserI::Execute </td>
          <td>(</td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes the specified function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">number</td><td>if the number of the callback to be executed. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classMARTe_1_1XMLParser.html#a170fb5f0595ebac275961fc0c6452baa">MARTe::XMLParser</a>, <a class="el" href="classMARTe_1_1JsonParser.html#aa407ea1bb84e682dbed878ca8952d80e">MARTe::JsonParser</a>, and <a class="el" href="classMARTe_1_1StandardParser.html#a3c2a5ab5ea9e43827692ca2511a9623b">MARTe::StandardParser</a>.</p>

</div>
</div>
<a class="anchor" id="af5125cf46ff25319f02bf9864f683caa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32 MARTe::ParserI::GetConflict </td>
          <td>(</td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the conflict number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>is the conflict row. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the conflict number. </dd></dl>

<p>Implemented in <a class="el" href="classMARTe_1_1XMLParser.html#a7133536aafbf35ca7d56ec5b1ccbd6ec">MARTe::XMLParser</a>, <a class="el" href="classMARTe_1_1JsonParser.html#a9ad94628fd966a16242edb86238cdc27">MARTe::JsonParser</a>, and <a class="el" href="classMARTe_1_1StandardParser.html#aff191bda970b6fd42a736aff0fe19e3a">MARTe::StandardParser</a>.</p>

</div>
</div>
<a class="anchor" id="a9dc5c63c6780e1670c9da396c1c9c7ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32 MARTe::ParserI::GetConflictRow </td>
          <td>(</td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the conflict array index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>is the expected token identifier. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classMARTe_1_1XMLParser.html#a4d161102a271f1ad500b528a3f5d2f32">MARTe::XMLParser</a>, <a class="el" href="classMARTe_1_1JsonParser.html#a22db596f8257529afe2f062b0867e42a">MARTe::JsonParser</a>, and <a class="el" href="classMARTe_1_1StandardParser.html#a4c4d8aa87d1ca251314a2912ed751b77">MARTe::StandardParser</a>.</p>

</div>
</div>
<a class="anchor" id="a515767fa92042c9b5fd3af9d7ee985f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32 MARTe::ParserI::GetConstant </td>
          <td>(</td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the constants used by the parser. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>is one of the <a class="el" href="namespaceMARTe_1_1ParserConstant.html" title="Namespace which defines the constants used by parsers. ">ParserConstant</a>, to retrieve the related constant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the desired constant. </dd></dl>

<p>Implemented in <a class="el" href="classMARTe_1_1XMLParser.html#a534ab09a7088c11de87deea35eaa9314">MARTe::XMLParser</a>, <a class="el" href="classMARTe_1_1JsonParser.html#a306d674c7a111ae5c31d6f2874e00c40">MARTe::JsonParser</a>, and <a class="el" href="classMARTe_1_1StandardParser.html#a076e203d48d2bc378dfcf663384820d8">MARTe::StandardParser</a>.</p>

</div>
</div>
<a class="anchor" id="adda1db7c382c368039efec0c06164423"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMARTe_1_1GrammarInfo.html">GrammarInfo</a> MARTe::ParserI::GetGrammarInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the grammar used by this parser. </p>
<dl class="section return"><dt>Returns</dt><dd>the grammar used by this parser. </dd></dl>

</div>
</div>
<a class="anchor" id="af4af29e5bb00ac0d938de1ad1c7399a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 MARTe::ParserI::GetNextTokenType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the identifier of the next token produced by the lexical analyzer. </p>
<dl class="section return"><dt>Returns</dt><dd>the identifier of the next token produced by the lexical analyzer. </dd></dl>

</div>
</div>
<a class="anchor" id="a5dfb7a998e1f8086dbe9df834ea76924"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32 MARTe::ParserI::GetParse </td>
          <td>(</td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the next token identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>is the parse row. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next token identifier. </dd></dl>

<p>Implemented in <a class="el" href="classMARTe_1_1XMLParser.html#a7d75b8f5f286ca0507f68c6544835d11">MARTe::XMLParser</a>, <a class="el" href="classMARTe_1_1JsonParser.html#ac09736ea71d536a4b9f2416de7f5444f">MARTe::JsonParser</a>, and <a class="el" href="classMARTe_1_1StandardParser.html#a9e2379a6cc47ea3056dddd8a26581a5c">MARTe::StandardParser</a>.</p>

</div>
</div>
<a class="anchor" id="ac6a57ea9d5ad0cfacbd289467e206075"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32 MARTe::ParserI::GetParseRow </td>
          <td>(</td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the index of the parse array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>is the expected token identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the parse array. </dd></dl>

<p>Implemented in <a class="el" href="classMARTe_1_1XMLParser.html#a0a4030bea98a3fd4e00c80e1c96d5173">MARTe::XMLParser</a>, <a class="el" href="classMARTe_1_1JsonParser.html#a3619daaf32e973ee97dc93e1e06d50a9">MARTe::JsonParser</a>, and <a class="el" href="classMARTe_1_1StandardParser.html#a29ce56213c76d4bb8376501408f8618a">MARTe::StandardParser</a>.</p>

</div>
</div>
<a class="anchor" id="ab24183e78dba324cb652241192315456"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32&amp; MARTe::ParserI::GetProduction </td>
          <td>(</td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the next expected token identifiers to be pushed on the stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>is the production row. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next expected tokens identifiers to be pushed on the stack. </dd></dl>

<p>Implemented in <a class="el" href="classMARTe_1_1XMLParser.html#acc1e15896648d4b8db6d99c7b983565d">MARTe::XMLParser</a>, <a class="el" href="classMARTe_1_1JsonParser.html#ac958035386791e87c1bc2a37303718dd">MARTe::JsonParser</a>, and <a class="el" href="classMARTe_1_1StandardParser.html#a9a1e8a11bcea642f28caaeea7a9a7228">MARTe::StandardParser</a>.</p>

</div>
</div>
<a class="anchor" id="a762832ea01a8ef079c6555195f001deb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32 MARTe::ParserI::GetProductionRow </td>
          <td>(</td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the index of the productions array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>is the expected token identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the productions array. </dd></dl>

<p>Implemented in <a class="el" href="classMARTe_1_1XMLParser.html#af9c72869fa3f50f8cae917a03c9df773">MARTe::XMLParser</a>, <a class="el" href="classMARTe_1_1JsonParser.html#ab75bc4db4f05397989f8f305b232f5cf">MARTe::JsonParser</a>, and <a class="el" href="classMARTe_1_1StandardParser.html#ab1b5f88c851226d916abfe18a25830be">MARTe::StandardParser</a>.</p>

</div>
</div>
<a class="anchor" id="a87ad10a50bd2d58c52bdff0d6a196253"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char8* MARTe::ParserI::GetSymbolName </td>
          <td>(</td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>symbol</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the name associated to the token. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">symbol</td><td>is the expected token identifier. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classMARTe_1_1XMLParser.html#adccbd8fbf5ce15761c7a2ad1d40a2d5a">MARTe::XMLParser</a>, <a class="el" href="classMARTe_1_1JsonParser.html#a546423b9e7e40b067bfc7dec1c43d09a">MARTe::JsonParser</a>, and <a class="el" href="classMARTe_1_1StandardParser.html#a58a44bde17421cd6f0a7f63d65cbb9ba">MARTe::StandardParser</a>.</p>

</div>
</div>
<a class="anchor" id="ac0ffe84eef1f75023e100fa1990687fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::ParserI::Parse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the stream in input and builds the configuration database accordingly. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the stream in input is parsed correctly, false otherwise. In case of failure, the error causing the failure is printed on the <em>err</em> stream in input (if it is not NULL). </dd></dl>

</div>
</div>
<a class="anchor" id="a2b66585af5a37a428a7880d1f9280fe8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 MARTe::ParserI::PeekNextTokenType </td>
          <td>(</td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Peeks in the token stack produced by the lexical analyzer, retrieves the identifier of the token in the next <em>position</em> index. </p>
<dl class="section return"><dt>Returns</dt><dd>the identifier of the token in the next <em>position</em> index. </dd></dl>

</div>
</div>
<a class="anchor" id="a86b895bb96422c68b5b5971839935d35"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 MARTe::ParserI::StackPop </td>
          <td>(</td>
          <td class="paramtype">uint32 *&amp;&#160;</td>
          <td class="paramname"><em>top</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pops the expected token from the internal stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">top</td><td>is a pointer to the stack head. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5adc64365d04d299ed3e1dd1ba6b8f06"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::ParserI::StackPush </td>
          <td>(</td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32 *const&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32 *&amp;&#160;</td>
          <td class="paramname"><em>top</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pushes the expected token to the stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">symbol</td><td>is the expected token. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stack</td><td>is the internal token stack. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">top</td><td>is a pointer to the stack head. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/pc/MARTe2Project/GIT/MARTe2/Source/Core/BareMetal/L4Configuration/<a class="el" href="ParserI_8h_source.html">ParserI.h</a></li>
<li>/home/pc/MARTe2Project/GIT/MARTe2/Source/Core/BareMetal/L4Configuration/<a class="el" href="ParserI_8cpp.html">ParserI.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
