<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>MARTe2-components: MARTe::IOBuffer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MARTe2-components
   </div>
   <div id="projectbrief">C++ real-time application development framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceMARTe.html">MARTe</a></li><li class="navelem"><a class="el" href="classMARTe_1_1IOBuffer.html">IOBuffer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classMARTe_1_1IOBuffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MARTe::IOBuffer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class which represents a generic input output buffer intended to be used by any kind of streams.  
 <a href="classMARTe_1_1IOBuffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="IOBuffer_8h_source.html">IOBuffer.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MARTe::IOBuffer:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classMARTe_1_1IOBuffer.png" usemap="#MARTe::IOBuffer_map" alt=""/>
  <map id="MARTe::IOBuffer_map" name="MARTe::IOBuffer_map">
<area href="classMARTe_1_1BufferedStreamIOBuffer.html" title="BufferedStreamIOBuffer class. " alt="MARTe::BufferedStreamIOBuffer" shape="rect" coords="0,56,196,80"/>
<area href="classMARTe_1_1StreamStringIOBuffer.html" title="The StreamString buffer. " alt="MARTe::StreamStringIOBuffer" shape="rect" coords="206,56,402,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a89e1011e26be5de1baed245a5d41aeb5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1IOBuffer.html#a89e1011e26be5de1baed245a5d41aeb5">Resync</a> ()</td></tr>
<tr class="memdesc:a89e1011e26be5de1baed245a5d41aeb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronizes the stream position with this buffer position.  <a href="#a89e1011e26be5de1baed245a5d41aeb5">More...</a><br /></td></tr>
<tr class="separator:a89e1011e26be5de1baed245a5d41aeb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cefa15dcbf7469a56771ab0fdf93870"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1IOBuffer.html#a0cefa15dcbf7469a56771ab0fdf93870">Seek</a> (const uint32 position)</td></tr>
<tr class="memdesc:a0cefa15dcbf7469a56771ab0fdf93870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the cursor to an absolute position.  <a href="#a0cefa15dcbf7469a56771ab0fdf93870">More...</a><br /></td></tr>
<tr class="separator:a0cefa15dcbf7469a56771ab0fdf93870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af77ddc526b011400fedc76b7ec81bae3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1IOBuffer.html#af77ddc526b011400fedc76b7ec81bae3">RelativeSeek</a> (const int32 delta)</td></tr>
<tr class="memdesc:af77ddc526b011400fedc76b7ec81bae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the cursor relatively from the current position.  <a href="#af77ddc526b011400fedc76b7ec81bae3">More...</a><br /></td></tr>
<tr class="separator:af77ddc526b011400fedc76b7ec81bae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9db4e41e4ae01eca00a4091c3df7455"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1IOBuffer.html#aa9db4e41e4ae01eca00a4091c3df7455">SetUsedSize</a> (const uint32 desiredSize)</td></tr>
<tr class="memdesc:aa9db4e41e4ae01eca00a4091c3df7455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets manually the size of the filled memory.  <a href="#aa9db4e41e4ae01eca00a4091c3df7455">More...</a><br /></td></tr>
<tr class="separator:aa9db4e41e4ae01eca00a4091c3df7455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ab6987ebd0490166dab6664284e1f0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1IOBuffer.html#a69ab6987ebd0490166dab6664284e1f0">IOBuffer</a> ()</td></tr>
<tr class="memdesc:a69ab6987ebd0490166dab6664284e1f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a69ab6987ebd0490166dab6664284e1f0">More...</a><br /></td></tr>
<tr class="separator:a69ab6987ebd0490166dab6664284e1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9889fde8a4868b2877e5d311d56273b5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1IOBuffer.html#a9889fde8a4868b2877e5d311d56273b5">IOBuffer</a> (const uint32 allocationGranularity, const uint32 newUndoLevel)</td></tr>
<tr class="memdesc:a9889fde8a4868b2877e5d311d56273b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with the granularity mask input.  <a href="#a9889fde8a4868b2877e5d311d56273b5">More...</a><br /></td></tr>
<tr class="separator:a9889fde8a4868b2877e5d311d56273b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334db2897d350ca6c94fd5917154becf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a334db2897d350ca6c94fd5917154becf"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1IOBuffer.html#a334db2897d350ca6c94fd5917154becf">~IOBuffer</a> ()</td></tr>
<tr class="memdesc:a334db2897d350ca6c94fd5917154becf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a334db2897d350ca6c94fd5917154becf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49277b49bc841b4c97ae5abc3d00dc70"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1IOBuffer.html#a49277b49bc841b4c97ae5abc3d00dc70">SetBufferHeapMemory</a> (const uint32 desiredSize, const uint32 reservedSpaceAtEnd)</td></tr>
<tr class="memdesc:a49277b49bc841b4c97ae5abc3d00dc70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates dynamically a memory portion on the heap.  <a href="#a49277b49bc841b4c97ae5abc3d00dc70">More...</a><br /></td></tr>
<tr class="separator:a49277b49bc841b4c97ae5abc3d00dc70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69f1b3472a8a385df1f22d9ac7fd149"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1IOBuffer.html#ab69f1b3472a8a385df1f22d9ac7fd149">SetBufferReferencedMemory</a> (char8 *const buffer, const uint32 bufferSize, const uint32 reservedSpaceAtEnd)</td></tr>
<tr class="memdesc:ab69f1b3472a8a385df1f22d9ac7fd149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a preallocated memory with read and write access.  <a href="#ab69f1b3472a8a385df1f22d9ac7fd149">More...</a><br /></td></tr>
<tr class="separator:ab69f1b3472a8a385df1f22d9ac7fd149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a940bb6aaa30f6db15620daee4e3a0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1IOBuffer.html#a57a940bb6aaa30f6db15620daee4e3a0">SetBufferReadOnlyReferencedMemory</a> (const char8 *const buffer, const uint32 bufferSize, const uint32 reservedSpaceAtEnd)</td></tr>
<tr class="memdesc:a57a940bb6aaa30f6db15620daee4e3a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a preallocated memory only with read access.  <a href="#a57a940bb6aaa30f6db15620daee4e3a0">More...</a><br /></td></tr>
<tr class="separator:a57a940bb6aaa30f6db15620daee4e3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea5e02daa94e3db3c5baf5acc60c17e6"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1IOBuffer.html#aea5e02daa94e3db3c5baf5acc60c17e6">GetBufferSize</a> () const </td></tr>
<tr class="memdesc:aea5e02daa94e3db3c5baf5acc60c17e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the allocated memory.  <a href="#aea5e02daa94e3db3c5baf5acc60c17e6">More...</a><br /></td></tr>
<tr class="separator:aea5e02daa94e3db3c5baf5acc60c17e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae185f39b78d9a805d0613f3477248205"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1IOBuffer.html#ae185f39b78d9a805d0613f3477248205">MaxUsableAmount</a> () const </td></tr>
<tr class="memdesc:ae185f39b78d9a805d0613f3477248205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size from the beginning to the end of memory (without considering the reserved space).  <a href="#ae185f39b78d9a805d0613f3477248205">More...</a><br /></td></tr>
<tr class="separator:ae185f39b78d9a805d0613f3477248205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6ca71e190564113cdd09d91e99f6ea"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1IOBuffer.html#afb6ca71e190564113cdd09d91e99f6ea">AmountLeft</a> () const </td></tr>
<tr class="memdesc:afb6ca71e190564113cdd09d91e99f6ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size from the cursor to the end of memory (without reserved space).  <a href="#afb6ca71e190564113cdd09d91e99f6ea">More...</a><br /></td></tr>
<tr class="separator:afb6ca71e190564113cdd09d91e99f6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6868a83848c383bc00928d7c769d40"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1IOBuffer.html#a8e6868a83848c383bc00928d7c769d40">UsedAmountLeft</a> () const </td></tr>
<tr class="memdesc:a8e6868a83848c383bc00928d7c769d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size from the cursor to the end of filled memory area.  <a href="#a8e6868a83848c383bc00928d7c769d40">More...</a><br /></td></tr>
<tr class="separator:a8e6868a83848c383bc00928d7c769d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26cb541c30df655e23f84213602e1bbc"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1IOBuffer.html#a26cb541c30df655e23f84213602e1bbc">Position</a> () const </td></tr>
<tr class="memdesc:a26cb541c30df655e23f84213602e1bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the cursor position.  <a href="#a26cb541c30df655e23f84213602e1bbc">More...</a><br /></td></tr>
<tr class="separator:a26cb541c30df655e23f84213602e1bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c5fedd50f86a4e7011a93ff81f45979"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1IOBuffer.html#a2c5fedd50f86a4e7011a93ff81f45979">UsedSize</a> () const </td></tr>
<tr class="memdesc:a2c5fedd50f86a4e7011a93ff81f45979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the filled memory area.  <a href="#a2c5fedd50f86a4e7011a93ff81f45979">More...</a><br /></td></tr>
<tr class="separator:a2c5fedd50f86a4e7011a93ff81f45979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6398576db2722177a5c0b4f96672e977"><td class="memItemLeft" align="right" valign="top">const char8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1IOBuffer.html#a6398576db2722177a5c0b4f96672e977">Buffer</a> () const </td></tr>
<tr class="memdesc:a6398576db2722177a5c0b4f96672e977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pointer at the beginning of the buffer in read only mode.  <a href="#a6398576db2722177a5c0b4f96672e977">More...</a><br /></td></tr>
<tr class="separator:a6398576db2722177a5c0b4f96672e977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c68a9c77a0cc36a3ae8c2618eeffe5e"><td class="memItemLeft" align="right" valign="top">char8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1IOBuffer.html#a2c68a9c77a0cc36a3ae8c2618eeffe5e">BufferReference</a> ()</td></tr>
<tr class="memdesc:a2c68a9c77a0cc36a3ae8c2618eeffe5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pointer at the beginning of the buffer in read-write mode.  <a href="#a2c68a9c77a0cc36a3ae8c2618eeffe5e">More...</a><br /></td></tr>
<tr class="separator:a2c68a9c77a0cc36a3ae8c2618eeffe5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46dcd9cb9b362f9f195d250d9d21c19f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46dcd9cb9b362f9f195d250d9d21c19f"></a>
uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1IOBuffer.html#a46dcd9cb9b362f9f195d250d9d21c19f">AllocationGranularity</a> () const </td></tr>
<tr class="memdesc:a46dcd9cb9b362f9f195d250d9d21c19f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the allocation granularity. <br /></td></tr>
<tr class="separator:a46dcd9cb9b362f9f195d250d9d21c19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321323f5c010e3060477f75e9ad73e3c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a321323f5c010e3060477f75e9ad73e3c"></a>
uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1IOBuffer.html#a321323f5c010e3060477f75e9ad73e3c">UndoLevel</a> () const </td></tr>
<tr class="memdesc:a321323f5c010e3060477f75e9ad73e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the UndoLevel. <br /></td></tr>
<tr class="separator:a321323f5c010e3060477f75e9ad73e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc3ac8ad2a8055f9eff2016ecc164d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1bc3ac8ad2a8055f9eff2016ecc164d1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1IOBuffer.html#a1bc3ac8ad2a8055f9eff2016ecc164d1">CanWrite</a> () const </td></tr>
<tr class="memdesc:a1bc3ac8ad2a8055f9eff2016ecc164d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the buffer is writable, false otherwise. <br /></td></tr>
<tr class="separator:a1bc3ac8ad2a8055f9eff2016ecc164d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace10993c34fe62ac76251af7a7723403"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1IOBuffer.html#ace10993c34fe62ac76251af7a7723403">PutC</a> (const char8 c)</td></tr>
<tr class="memdesc:ace10993c34fe62ac76251af7a7723403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts a character on the buffer.  <a href="#ace10993c34fe62ac76251af7a7723403">More...</a><br /></td></tr>
<tr class="separator:ace10993c34fe62ac76251af7a7723403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d78cb60c46067e50e607cbce7350cbc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1IOBuffer.html#a8d78cb60c46067e50e607cbce7350cbc">UnPutC</a> ()</td></tr>
<tr class="memdesc:a8d78cb60c46067e50e607cbce7350cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">If possible remove the last character from the buffer.  <a href="#a8d78cb60c46067e50e607cbce7350cbc">More...</a><br /></td></tr>
<tr class="separator:a8d78cb60c46067e50e607cbce7350cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4da63d565004d059e8ca97f1c6abe81"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1IOBuffer.html#aa4da63d565004d059e8ca97f1c6abe81">GetC</a> (char8 &amp;c)</td></tr>
<tr class="memdesc:aa4da63d565004d059e8ca97f1c6abe81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a character from the buffer.  <a href="#aa4da63d565004d059e8ca97f1c6abe81">More...</a><br /></td></tr>
<tr class="separator:aa4da63d565004d059e8ca97f1c6abe81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcefb2fd95104bf8cf89d82c77cf3e1f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1IOBuffer.html#adcefb2fd95104bf8cf89d82c77cf3e1f">UnGetC</a> ()</td></tr>
<tr class="memdesc:adcefb2fd95104bf8cf89d82c77cf3e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If possible decrements the cursor.  <a href="#adcefb2fd95104bf8cf89d82c77cf3e1f">More...</a><br /></td></tr>
<tr class="separator:adcefb2fd95104bf8cf89d82c77cf3e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f0a1de2a3d9ea967c2d55dc394bb44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1IOBuffer.html#a14f0a1de2a3d9ea967c2d55dc394bb44">Empty</a> ()</td></tr>
<tr class="memdesc:a14f0a1de2a3d9ea967c2d55dc394bb44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empties the buffer.  <a href="#a14f0a1de2a3d9ea967c2d55dc394bb44">More...</a><br /></td></tr>
<tr class="separator:a14f0a1de2a3d9ea967c2d55dc394bb44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec2068d67df95dcfc71544896081421e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1IOBuffer.html#aec2068d67df95dcfc71544896081421e">Write</a> (const char8 *const buffer, uint32 &amp;size)</td></tr>
<tr class="memdesc:aec2068d67df95dcfc71544896081421e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes from an input buffer.  <a href="#aec2068d67df95dcfc71544896081421e">More...</a><br /></td></tr>
<tr class="separator:aec2068d67df95dcfc71544896081421e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e2b5ee650f8746dc87f86f489204a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1IOBuffer.html#a76e2b5ee650f8746dc87f86f489204a7">WriteAll</a> (const char8 *buffer, const uint32 &amp;size)</td></tr>
<tr class="memdesc:a76e2b5ee650f8746dc87f86f489204a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes all the size in the argument from an input buffer.  <a href="#a76e2b5ee650f8746dc87f86f489204a7">More...</a><br /></td></tr>
<tr class="separator:a76e2b5ee650f8746dc87f86f489204a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4ef5ba8adf00c4834afa8c6a348528"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1IOBuffer.html#a9b4ef5ba8adf00c4834afa8c6a348528">Read</a> (char8 *const buffer, uint32 &amp;size)</td></tr>
<tr class="memdesc:a9b4ef5ba8adf00c4834afa8c6a348528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads from this buffer to an output buffer.  <a href="#a9b4ef5ba8adf00c4834afa8c6a348528">More...</a><br /></td></tr>
<tr class="separator:a9b4ef5ba8adf00c4834afa8c6a348528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac862c4a1d5a6b0da3985c879a137e0f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1IOBuffer.html#ac862c4a1d5a6b0da3985c879a137e0f6">PrintFormatted</a> (const char8 *format, const <a class="el" href="classMARTe_1_1AnyType.html">AnyType</a> pars[])</td></tr>
<tr class="memdesc:ac862c4a1d5a6b0da3985c879a137e0f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function called by all Printf operations.  <a href="#ac862c4a1d5a6b0da3985c879a137e0f6">More...</a><br /></td></tr>
<tr class="separator:ac862c4a1d5a6b0da3985c879a137e0f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acddb332a3240ece299b38b3e715c3a2e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1IOBuffer.html#acddb332a3240ece299b38b3e715c3a2e">GetToken</a> (char8 *outputBuffer, const char8 *terminator, uint32 outputBufferSize, char8 &amp;saveTerminator, const char8 *skipCharacters)</td></tr>
<tr class="memdesc:acddb332a3240ece299b38b3e715c3a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a token from the buffer and writes it on an output buffer.  <a href="#acddb332a3240ece299b38b3e715c3a2e">More...</a><br /></td></tr>
<tr class="separator:acddb332a3240ece299b38b3e715c3a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa85752348c09884dfde40da2a9136976"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1IOBuffer.html#aa85752348c09884dfde40da2a9136976">GetToken</a> (<a class="el" href="classMARTe_1_1IOBuffer.html">IOBuffer</a> &amp;outputBuffer, const char8 *terminator, char8 &amp;saveTerminator, const char8 *skipCharacters)</td></tr>
<tr class="memdesc:aa85752348c09884dfde40da2a9136976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a token from the buffer and writes it on an output buffer.  <a href="#aa85752348c09884dfde40da2a9136976">More...</a><br /></td></tr>
<tr class="separator:aa85752348c09884dfde40da2a9136976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade098000697dbf4b2dc5fc6e2ab84f46"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1IOBuffer.html#ade098000697dbf4b2dc5fc6e2ab84f46">SkipTokens</a> (uint32 count, const char8 *terminator)</td></tr>
<tr class="memdesc:ade098000697dbf4b2dc5fc6e2ab84f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skips a number of tokens on the buffer.  <a href="#ade098000697dbf4b2dc5fc6e2ab84f46">More...</a><br /></td></tr>
<tr class="separator:ade098000697dbf4b2dc5fc6e2ab84f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eddc67592780390aa0d192cdd2407ee"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1IOBuffer.html#a2eddc67592780390aa0d192cdd2407ee">Refill</a> ()</td></tr>
<tr class="memdesc:a2eddc67592780390aa0d192cdd2407ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">User friendly function which simply calls NoMoreDataToRead.  <a href="#a2eddc67592780390aa0d192cdd2407ee">More...</a><br /></td></tr>
<tr class="separator:a2eddc67592780390aa0d192cdd2407ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3dbe8d4c6cb63c6d283d6ee96a79e1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1IOBuffer.html#afc3dbe8d4c6cb63c6d283d6ee96a79e1">Flush</a> (const uint32 neededSize=0u)</td></tr>
<tr class="memdesc:afc3dbe8d4c6cb63c6d283d6ee96a79e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">User friendly function which simply calls NoMoreSpaceToWrite.  <a href="#afc3dbe8d4c6cb63c6d283d6ee96a79e1">More...</a><br /></td></tr>
<tr class="separator:afc3dbe8d4c6cb63c6d283d6ee96a79e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d83270e6670f7dda1b939e80e4e3a9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1IOBuffer.html#a89d83270e6670f7dda1b939e80e4e3a9">NoMoreSpaceToWrite</a> ()</td></tr>
<tr class="separator:a89d83270e6670f7dda1b939e80e4e3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab991fa1f753cd9cc387f894577ac60ce"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1IOBuffer.html#ab991fa1f753cd9cc387f894577ac60ce">NoMoreSpaceToWrite</a> (uint32 neededSize)</td></tr>
<tr class="memdesc:ab991fa1f753cd9cc387f894577ac60ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">The routine executed in PutC when amountLeft is &lt;= <a class="el" href="classMARTe_1_1IOBuffer.html#a321323f5c010e3060477f75e9ad73e3c" title="Gets the UndoLevel. ">UndoLevel()</a>, namely the cursor arrived to a specific position.  <a href="#ab991fa1f753cd9cc387f894577ac60ce">More...</a><br /></td></tr>
<tr class="separator:ab991fa1f753cd9cc387f894577ac60ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9313f878d207afb7aee73ebc08fcb0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1IOBuffer.html#a4d9313f878d207afb7aee73ebc08fcb0">NoMoreDataToRead</a> ()</td></tr>
<tr class="memdesc:a4d9313f878d207afb7aee73ebc08fcb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The routine executed in GetC when amountLeft is &lt;= <a class="el" href="classMARTe_1_1IOBuffer.html#a321323f5c010e3060477f75e9ad73e3c" title="Gets the UndoLevel. ">UndoLevel()</a>, namely the cursor arrived to a specific position.  <a href="#a4d9313f878d207afb7aee73ebc08fcb0">More...</a><br /></td></tr>
<tr class="separator:a4d9313f878d207afb7aee73ebc08fcb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class which represents a generic input output buffer intended to be used by any kind of streams. </p>
<p>This class represents a naked memory buffer with a pointer at the beginning. It adds a movable pointer across the memory area and attributes to get the size of the filled area and the readable area of the buffer.</p>
<p>This class implements basic methods for read, write and seek operations on the buffer which are virtual to avoid overloading in children.</p>
<p>The most important functions are the inline PutC and GetC which are used in Printf and GetToken functions and are shared by all children (besides the implementation of NoMoreSpaceToWrite and NoMoreDataToRead depends on the specific derived class implementation) </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a69ab6987ebd0490166dab6664284e1f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MARTe::IOBuffer::IOBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<dl class="section pre"><dt>Precondition</dt><dd>true </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classMARTe_1_1IOBuffer.html#a6398576db2722177a5c0b4f96672e977" title="Gets the pointer at the beginning of the buffer in read only mode. ">Buffer()</a> == NULL &amp;&amp; <a class="el" href="classMARTe_1_1IOBuffer.html#aea5e02daa94e3db3c5baf5acc60c17e6" title="Gets the size of the allocated memory. ">GetBufferSize()</a> == 0u &amp;&amp; <a class="el" href="classMARTe_1_1IOBuffer.html#afb6ca71e190564113cdd09d91e99f6ea" title="Gets the size from the cursor to the end of memory (without reserved space). ">AmountLeft()</a> == 0u &amp;&amp; <a class="el" href="classMARTe_1_1IOBuffer.html#ae185f39b78d9a805d0613f3477248205" title="Gets the size from the beginning to the end of memory (without considering the reserved space)...">MaxUsableAmount()</a> == 0u &amp;&amp; <a class="el" href="classMARTe_1_1IOBuffer.html#a8e6868a83848c383bc00928d7c769d40" title="Gets the size from the cursor to the end of filled memory area. ">UsedAmountLeft()</a> == 0 &amp;&amp; <a class="el" href="classMARTe_1_1IOBuffer.html#a26cb541c30df655e23f84213602e1bbc" title="Gets the cursor position. ">Position()</a> == 0u &amp;&amp; <a class="el" href="classMARTe_1_1IOBuffer.html#a2c5fedd50f86a4e7011a93ff81f45979" title="Gets the size of the filled memory area. ">UsedSize()</a> == 0 &amp;&amp; <a class="el" href="classMARTe_1_1IOBuffer.html#a46dcd9cb9b362f9f195d250d9d21c19f" title="Gets the allocation granularity. ">AllocationGranularity()</a> == 1u &amp;&amp; <a class="el" href="classMARTe_1_1IOBuffer.html#a321323f5c010e3060477f75e9ad73e3c" title="Gets the UndoLevel. ">UndoLevel()</a> == 0 &amp;&amp; not <a class="el" href="classMARTe_1_1IOBuffer.html#a1bc3ac8ad2a8055f9eff2016ecc164d1" title="Returns true if the buffer is writable, false otherwise. ">CanWrite()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9889fde8a4868b2877e5d311d56273b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MARTe::IOBuffer::IOBuffer </td>
          <td>(</td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>allocationGranularity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>newUndoLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor with the granularity mask input. </p>
<dl class="section pre"><dt>Precondition</dt><dd>true </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classMARTe_1_1IOBuffer.html#a6398576db2722177a5c0b4f96672e977" title="Gets the pointer at the beginning of the buffer in read only mode. ">Buffer()</a> == NULL &amp;&amp; <a class="el" href="classMARTe_1_1IOBuffer.html#aea5e02daa94e3db3c5baf5acc60c17e6" title="Gets the size of the allocated memory. ">GetBufferSize()</a> == 0u &amp;&amp; <a class="el" href="classMARTe_1_1IOBuffer.html#afb6ca71e190564113cdd09d91e99f6ea" title="Gets the size from the cursor to the end of memory (without reserved space). ">AmountLeft()</a> == 0u &amp;&amp; <a class="el" href="classMARTe_1_1IOBuffer.html#ae185f39b78d9a805d0613f3477248205" title="Gets the size from the beginning to the end of memory (without considering the reserved space)...">MaxUsableAmount()</a> == 0u &amp;&amp; <a class="el" href="classMARTe_1_1IOBuffer.html#a8e6868a83848c383bc00928d7c769d40" title="Gets the size from the cursor to the end of filled memory area. ">UsedAmountLeft()</a> == 0 &amp;&amp; <a class="el" href="classMARTe_1_1IOBuffer.html#a26cb541c30df655e23f84213602e1bbc" title="Gets the cursor position. ">Position()</a> == 0u &amp;&amp; <a class="el" href="classMARTe_1_1IOBuffer.html#a2c5fedd50f86a4e7011a93ff81f45979" title="Gets the size of the filled memory area. ">UsedSize()</a> == 0 &amp;&amp; <a class="el" href="classMARTe_1_1IOBuffer.html#a46dcd9cb9b362f9f195d250d9d21c19f" title="Gets the allocation granularity. ">AllocationGranularity()</a> == allocationGranularity &amp;&amp; <a class="el" href="classMARTe_1_1IOBuffer.html#a321323f5c010e3060477f75e9ad73e3c" title="Gets the UndoLevel. ">UndoLevel()</a> == newUndoLevel &amp;&amp; not <a class="el" href="classMARTe_1_1IOBuffer.html#a1bc3ac8ad2a8055f9eff2016ecc164d1" title="Returns true if the buffer is writable, false otherwise. ">CanWrite()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="afb6ca71e190564113cdd09d91e99f6ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 MARTe::IOBuffer::AmountLeft </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size from the cursor to the end of memory (without reserved space). </p>
<dl class="section return"><dt>Returns</dt><dd>the usable space remained from the current position. </dd></dl>

</div>
</div>
<a class="anchor" id="a6398576db2722177a5c0b4f96672e977"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char8 * MARTe::IOBuffer::Buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the pointer at the beginning of the buffer in read only mode. </p>
<dl class="section return"><dt>Returns</dt><dd>the pointer at the beginning of the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a2c68a9c77a0cc36a3ae8c2618eeffe5e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char8 * MARTe::IOBuffer::BufferReference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the pointer at the beginning of the buffer in read-write mode. </p>
<dl class="section return"><dt>Returns</dt><dd>the pointer at the beginning of the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a14f0a1de2a3d9ea967c2d55dc394bb44"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::IOBuffer::Empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empties the buffer. </p>
<p>Sets amountLeft and fill to maxUsableAmount. Then sets the buffer pointer at the beginning. </p>

</div>
</div>
<a class="anchor" id="afc3dbe8d4c6cb63c6d283d6ee96a79e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::IOBuffer::Flush </td>
          <td>(</td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>neededSize</em> = <code>0u</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User friendly function which simply calls NoMoreSpaceToWrite. </p>
<dl class="section return"><dt>Returns</dt><dd>whatever NoMoreSpaceToWrite returns. </dd></dl>

<p>Reimplemented in <a class="el" href="classMARTe_1_1BufferedStreamIOBuffer.html#aa5cfe920207d743a73358194a30937fa">MARTe::BufferedStreamIOBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="aea5e02daa94e3db3c5baf5acc60c17e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 MARTe::IOBuffer::GetBufferSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size of the allocated memory. </p>
<dl class="section return"><dt>Returns</dt><dd>the size of the allocated memory. </dd></dl>

</div>
</div>
<a class="anchor" id="aa4da63d565004d059e8ca97f1c6abe81"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::IOBuffer::GetC </td>
          <td>(</td>
          <td class="paramtype">char8 &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a character from the buffer. </p>
<p>This function calls NoMoreDataToRead which can for example refill this buffer from the stream (<a class="el" href="classMARTe_1_1BufferedStreamIOBuffer.html" title="BufferedStreamIOBuffer class. ">BufferedStreamIOBuffer</a>) when the cursor is in a specific position defined by <a class="el" href="classMARTe_1_1IOBuffer.html#a321323f5c010e3060477f75e9ad73e3c" title="Gets the UndoLevel. ">UndoLevel()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>is the character in return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if the cursor is at the end of the filled memory, true otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="acddb332a3240ece299b38b3e715c3a2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::IOBuffer::GetToken </td>
          <td>(</td>
          <td class="paramtype">char8 *&#160;</td>
          <td class="paramname"><em>outputBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char8 *&#160;</td>
          <td class="paramname"><em>terminator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>outputBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char8 &amp;&#160;</td>
          <td class="paramname"><em>saveTerminator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char8 *&#160;</td>
          <td class="paramname"><em>skipCharacters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a token from the buffer and writes it on an output buffer. </p>
<p>Extracts a token from the buffer into a string data until a terminator or 0 is found. Skips all skip characters, if you want to skip also terminator characters at the beginning add them to the skip characters. The terminator (just the first encountered) is consumed in the process and saved in saveTerminator if provided skipCharacters=NULL is equivalent to skipCharacters = terminator A character can be found in the terminator or in the skipCharacters list in both or in none 0) none the character is copied. 1) terminator the character is not copied the string is terminated. 2) skip the character is not copied. 3) skip + terminator the character is not copied, the string is terminated only if not empty. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outputBuffer</td><td>is the output buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">terminator</td><td>is a list of terminator characters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outputBufferSize</td><td>is the size of the output buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">saveTerminator</td><td>is the found terminator in return. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">skipCharacters</td><td>is a list of characters to be skipped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if some data was read before any error or file termination, false only on error and no data available. </dd></dl>

</div>
</div>
<a class="anchor" id="aa85752348c09884dfde40da2a9136976"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::IOBuffer::GetToken </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMARTe_1_1IOBuffer.html">IOBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>outputBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char8 *&#160;</td>
          <td class="paramname"><em>terminator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char8 &amp;&#160;</td>
          <td class="paramname"><em>saveTerminator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char8 *&#160;</td>
          <td class="paramname"><em>skipCharacters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a token from the buffer and writes it on an output buffer. </p>
<p>Extracts a token from the buffer into a string data until a terminator or 0 is found. Skips all skip characters and those that are also terminators at the beginning. The terminator (just the first encountered) is consumed in the process and saved in saveTerminator if provided skipCharacters=NULL is equivalent to skipCharacters = terminator {BUFFERED} A character can be found in the terminator or in the skipCharacters list in both or in none 0) none the character is copied. 1) terminator the character is not copied the string is terminated. 2) skip the character is not copied. 3) skip + terminator the character is not copied, the string is terminated if not empty. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outputBuffer</td><td>is the output buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">terminator</td><td>is a list of terminator characters. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">saveTerminator</td><td>is the found terminator in return. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">skipCharacters</td><td>is a list of characters to be skipped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if no data read, true otherwise. </dd>
<dd>
true if some data was read before any error or file termination. false only on error and no data available. </dd></dl>

</div>
</div>
<a class="anchor" id="ae185f39b78d9a805d0613f3477248205"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 MARTe::IOBuffer::MaxUsableAmount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size from the beginning to the end of memory (without considering the reserved space). </p>
<dl class="section return"><dt>Returns</dt><dd>the usable buffer size. </dd></dl>

</div>
</div>
<a class="anchor" id="a4d9313f878d207afb7aee73ebc08fcb0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::IOBuffer::NoMoreDataToRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The routine executed in GetC when amountLeft is &lt;= <a class="el" href="classMARTe_1_1IOBuffer.html#a321323f5c010e3060477f75e9ad73e3c" title="Gets the UndoLevel. ">UndoLevel()</a>, namely the cursor arrived to a specific position. </p>
<p>This implementation is basic and only returns false.</p>
<p>In <a class="el" href="classMARTe_1_1BufferedStreamIOBuffer.html" title="BufferedStreamIOBuffer class. ">BufferedStreamIOBuffer</a> <a class="el" href="classMARTe_1_1IOBuffer.html#a321323f5c010e3060477f75e9ad73e3c" title="Gets the UndoLevel. ">UndoLevel()</a> is zero, so when the cursor arrives at the end of the memory this function refills the buffer from the stream for a new read operation.</p>
<dl class="section return"><dt>Returns</dt><dd>false in this implementation. </dd></dl>

<p>Reimplemented in <a class="el" href="classMARTe_1_1BufferedStreamIOBuffer.html#a5977a278d8d563a049a47be95fb82b0d">MARTe::BufferedStreamIOBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a89d83270e6670f7dda1b939e80e4e3a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::IOBuffer::NoMoreSpaceToWrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classMARTe_1_1IOBuffer.html#ab991fa1f753cd9cc387f894577ac60ce" title="The routine executed in PutC when amountLeft is &lt;= UndoLevel(), namely the cursor arrived to a specif...">NoMoreSpaceToWrite(const uint32)</a> </dd></dl>

<p>Reimplemented in <a class="el" href="classMARTe_1_1BufferedStreamIOBuffer.html#af092fff70409943c4119b59f2e218e89">MARTe::BufferedStreamIOBuffer</a>, and <a class="el" href="classMARTe_1_1StreamStringIOBuffer.html#ad4090ee555cfb2a96d8da39d119c5691">MARTe::StreamStringIOBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="ab991fa1f753cd9cc387f894577ac60ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::IOBuffer::NoMoreSpaceToWrite </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>neededSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The routine executed in PutC when amountLeft is &lt;= <a class="el" href="classMARTe_1_1IOBuffer.html#a321323f5c010e3060477f75e9ad73e3c" title="Gets the UndoLevel. ">UndoLevel()</a>, namely the cursor arrived to a specific position. </p>
<p>This basic implementation only returns false.<br />
 In <a class="el" href="classMARTe_1_1StreamStringIOBuffer.html" title="The StreamString buffer. ">StreamStringIOBuffer</a> <a class="el" href="classMARTe_1_1IOBuffer.html#a321323f5c010e3060477f75e9ad73e3c" title="Gets the UndoLevel. ">UndoLevel()</a> is zero, so when the cursor arrived at the end of the memory, this function allocated a new portion of memory in the queue.<br />
 In <a class="el" href="classMARTe_1_1BufferedStreamIOBuffer.html" title="BufferedStreamIOBuffer class. ">BufferedStreamIOBuffer</a> <a class="el" href="classMARTe_1_1IOBuffer.html#a321323f5c010e3060477f75e9ad73e3c" title="Gets the UndoLevel. ">UndoLevel()</a> is zero, so when the cursor arrived at the end of the memory this function flushes this buffer to the stream.<br />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">neededSize</td><td>is the size of the memory to be allocated or flushed (not used at this implementation level). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false at this implementation level. </dd></dl>

<p>Reimplemented in <a class="el" href="classMARTe_1_1StreamStringIOBuffer.html#a0e2cebb77e735a14e61dc11783c80d52">MARTe::StreamStringIOBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a26cb541c30df655e23f84213602e1bbc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 MARTe::IOBuffer::Position </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the cursor position. </p>
<dl class="section return"><dt>Returns</dt><dd>the current position, namely the size from the beginning to the cursor. </dd></dl>

</div>
</div>
<a class="anchor" id="ac862c4a1d5a6b0da3985c879a137e0f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::IOBuffer::PrintFormatted </td>
          <td>(</td>
          <td class="paramtype">const char8 *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMARTe_1_1AnyType.html">AnyType</a>&#160;</td>
          <td class="paramname"><em>pars</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function called by all Printf operations. </p>
<p>This function read the format, builds the related format descriptor and then calls the PrintToStream function passing the next <a class="el" href="classMARTe_1_1AnyType.html" title="Class which provides a smart mechanism for the generic representation of types. ">AnyType</a> element in the list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>is a printf-like string format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pars</td><td>is a list of <a class="el" href="classMARTe_1_1AnyType.html" title="Class which provides a smart mechanism for the generic representation of types. ">AnyType</a> elements to print. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false in case of errors. </dd></dl>

</div>
</div>
<a class="anchor" id="ace10993c34fe62ac76251af7a7723403"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::IOBuffer::PutC </td>
          <td>(</td>
          <td class="paramtype">const char8&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Puts a character on the buffer. </p>
<p>This function is called by formatted print-like functions for buffered streams. The implementation of NoMoreSpaceToWrite depends on children classes and it could be for example a flush (<a class="el" href="classMARTe_1_1BufferedStreamIOBuffer.html" title="BufferedStreamIOBuffer class. ">BufferedStreamIOBuffer</a>) or a new allocation (<a class="el" href="classMARTe_1_1StreamStringIOBuffer.html" title="The StreamString buffer. ">StreamStringIOBuffer</a>).<br />
 The value of <a class="el" href="classMARTe_1_1IOBuffer.html#a321323f5c010e3060477f75e9ad73e3c" title="Gets the UndoLevel. ">UndoLevel()</a> could be used to trigger the call to NoMoreSpaceToWrite when the cursor is at a specific position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>is the character to copy on this buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if there is no space to write or the buffer is not writable, true otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a9b4ef5ba8adf00c4834afa8c6a348528"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::IOBuffer::Read </td>
          <td>(</td>
          <td class="paramtype">char8 *const&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32 &amp;&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads from this buffer to an output buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>is the output buffer where data must be written. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">size</td><td>is the number of bytes to be read. This value will be clipped to the space left if needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if errors copying data </dd></dl>

</div>
</div>
<a class="anchor" id="a2eddc67592780390aa0d192cdd2407ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::IOBuffer::Refill </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User friendly function which simply calls NoMoreDataToRead. </p>
<dl class="section return"><dt>Returns</dt><dd>whatever NoMoreDataToRead returns. </dd></dl>

<p>Reimplemented in <a class="el" href="classMARTe_1_1BufferedStreamIOBuffer.html#a561162183a56ab4b9059628964a5681e">MARTe::BufferedStreamIOBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="af77ddc526b011400fedc76b7ec81bae3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::IOBuffer::RelativeSeek </td>
          <td>(</td>
          <td class="paramtype">const int32&#160;</td>
          <td class="paramname"><em>delta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the cursor relatively from the current position. </p>
<p>Checks that the final position is &gt;= 0 and &lt;= UsedSize, then moves the cursor.<br />
-If the final position is &lt; 0 moves the cursor at the beginning.<br />
-If the final position is &gt; UsedSize moves the cursor at the end.<br />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">delta</td><td>is the step from the current position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if the final calculated position falls out of ranges, true otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a89e1011e26be5de1baed245a5d41aeb5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::IOBuffer::Resync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronizes the stream position with this buffer position. </p>
<p>This implementation is basic and only returns false. In <a class="el" href="classMARTe_1_1BufferedStreamIOBuffer.html" title="BufferedStreamIOBuffer class. ">BufferedStreamIOBuffer</a> flushes the write buffer after write operations or adjusts the stream position (shifted after a refill because of a previous read operation). </p><dl class="section return"><dt>Returns</dt><dd>false in this implementation. </dd></dl>

<p>Reimplemented in <a class="el" href="classMARTe_1_1BufferedStreamIOBuffer.html#a8e8412183c6b9c6581e0d8ff7ba8667d">MARTe::BufferedStreamIOBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a0cefa15dcbf7469a56771ab0fdf93870"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::IOBuffer::Seek </td>
          <td>(</td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the cursor to an absolute position. </p>
<p>Adjusts <a class="el" href="classMARTe_1_1IOBuffer.html#afb6ca71e190564113cdd09d91e99f6ea" title="Gets the size from the cursor to the end of memory (without reserved space). ">AmountLeft()</a> == <a class="el" href="classMARTe_1_1IOBuffer.html#ae185f39b78d9a805d0613f3477248205" title="Gets the size from the beginning to the end of memory (without considering the reserved space)...">MaxUsableAmount()</a> - position<br />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>is the desired position in the filled memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if position is greater than the size of the filled memory. </dd></dl>

</div>
</div>
<a class="anchor" id="a49277b49bc841b4c97ae5abc3d00dc70"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::IOBuffer::SetBufferHeapMemory </td>
          <td>(</td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>desiredSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>reservedSpaceAtEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates dynamically a memory portion on the heap. </p>
<p>-If the new size (desiredSize-reservedSpaceAtEnd) is minor than the current used size, usedSize is clipped and if the position was over, it becomes the end of the new size.<br />
-This function fixes maxUsableAmount to desiredSize-reservedSpaceAtEnd.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredSize</td><td>is the desired size to be allocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reservedSpaceAtEnd</td><td>is the space allocated over the usable memory area (maxUsableAmount does not consider it).<br />
It could be for example the zero terminator character at the end of a string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if the allocation fails, true otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a57a940bb6aaa30f6db15620daee4e3a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::IOBuffer::SetBufferReadOnlyReferencedMemory </td>
          <td>(</td>
          <td class="paramtype">const char8 *const&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>reservedSpaceAtEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a preallocated memory only with read access. </p>
<p>Sets the buffer as empty and maxUsableAmount = (bufferSize - reservedSpaceAtEnd).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>is a pointer to a preallocated memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>is the size of the memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reservedSpaceAtEnd</td><td>is the memory allocated but not . </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab69f1b3472a8a385df1f22d9ac7fd149"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::IOBuffer::SetBufferReferencedMemory </td>
          <td>(</td>
          <td class="paramtype">char8 *const&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>reservedSpaceAtEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a preallocated memory with read and write access. </p>
<p>Sets the buffer as empty and maxUsableAmount = (bufferSize - reservedSpaceAtEnd).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>is a pointer to a preallocated memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>is the size of the memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reservedSpaceAtEnd</td><td>is the memory allocated over the usable memory area. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa9db4e41e4ae01eca00a4091c3df7455"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MARTe::IOBuffer::SetUsedSize </td>
          <td>(</td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>desiredSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets manually the size of the filled memory. </p>
<p>If the desired size is greater than maxUsableAmount it clips the desired size to maxUsableAmount.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredSize</td><td>is the desired used size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ade098000697dbf4b2dc5fc6e2ab84f46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::IOBuffer::SkipTokens </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char8 *&#160;</td>
          <td class="paramname"><em>terminator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Skips a number of tokens on the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">count</td><td>is the number of tokens to be skipped. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">terminator</td><td>is a list of terminator characters for the tokenize operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if the number of skipped tokens is minor than the desired. </dd></dl>

</div>
</div>
<a class="anchor" id="adcefb2fd95104bf8cf89d82c77cf3e1f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::IOBuffer::UnGetC </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If possible decrements the cursor. </p>
<p>It decrements the cursor and increments amountLeft.</p>
<dl class="section return"><dt>Returns</dt><dd>false if the cursor is at the beginning, true otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a8d78cb60c46067e50e607cbce7350cbc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::IOBuffer::UnPutC </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If possible remove the last character from the buffer. </p>
<p>Increments amountLeft and decrements the cursor.</p>
<dl class="section return"><dt>Returns</dt><dd>false if the position is at the beginning, true otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a8e6868a83848c383bc00928d7c769d40"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 MARTe::IOBuffer::UsedAmountLeft </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size from the cursor to the end of filled memory area. </p>
<dl class="section return"><dt>Returns</dt><dd>the space remained from the current position to the end of the filled memory in the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a2c5fedd50f86a4e7011a93ff81f45979"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 MARTe::IOBuffer::UsedSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size of the filled memory area. </p>
<dl class="section return"><dt>Returns</dt><dd>the size of the filled memory area. </dd></dl>

</div>
</div>
<a class="anchor" id="aec2068d67df95dcfc71544896081421e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::IOBuffer::Write </td>
          <td>(</td>
          <td class="paramtype">const char8 *const&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32 &amp;&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes from an input buffer. </p>
<p>The function does nothing if <a class="el" href="classMARTe_1_1CharBuffer.html#aa3581d2ca2d63815ca86e12162769640" title="Queries if the buffer is writable. ">CharBuffer::CanWrite</a> returns false, otherwise copy size bytes from the input buffer, sets the cursor size positions forward and adjusts fillLeft and amountLeft accordingly.<br />
If size is greater than amountLeft is clipped. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>contains the data to be written in this buffer. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">size</td><td>is the number of bytes to be copied. This value will be clipped to the space left if needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if errors copying data </dd></dl>

<p>Reimplemented in <a class="el" href="classMARTe_1_1StreamStringIOBuffer.html#afd90ab238fdb43b7cb5a11c6ca177f21">MARTe::StreamStringIOBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a76e2b5ee650f8746dc87f86f489204a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::IOBuffer::WriteAll </td>
          <td>(</td>
          <td class="paramtype">const char8 *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32 &amp;&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes all the size in the argument from an input buffer. </p>
<p>This function calls Write and NoMoreSpaceToWrite until size is consumed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>contains data to be written in this buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>is the number of byte to be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/pc/MARTe2Project/GIT/MARTe2/Source/Core/BareMetal/L3Streams/<a class="el" href="IOBuffer_8h_source.html">IOBuffer.h</a></li>
<li>/home/pc/MARTe2Project/GIT/MARTe2/Source/Core/BareMetal/L3Streams/<a class="el" href="IOBuffer_8cpp.html">IOBuffer.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
