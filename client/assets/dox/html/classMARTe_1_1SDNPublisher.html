<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MARTe2-components: MARTe::SDNPublisher Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MARTe2-components
   </div>
   <div id="projectbrief">C++ real-time application development framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>MARTe</b></li><li class="navelem"><a class="el" href="classMARTe_1_1SDNPublisher.html">SDNPublisher</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classMARTe_1_1SDNPublisher-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MARTe::SDNPublisher Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A DataSource which collects and publishes signals over the ITER SDN.  
 <a href="classMARTe_1_1SDNPublisher.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="SDNPublisher_8h_source.html">SDNPublisher.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MARTe::SDNPublisher:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classMARTe_1_1SDNPublisher.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aafba07f4ab591c44f3efe5873a7671e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1SDNPublisher.html#aafba07f4ab591c44f3efe5873a7671e2">SDNPublisher</a> ()</td></tr>
<tr class="memdesc:aafba07f4ab591c44f3efe5873a7671e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classMARTe_1_1SDNPublisher.html#aafba07f4ab591c44f3efe5873a7671e2">More...</a><br /></td></tr>
<tr class="separator:aafba07f4ab591c44f3efe5873a7671e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dba4900f54dd5a27653c71c17ac3be8"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1SDNPublisher.html#a0dba4900f54dd5a27653c71c17ac3be8">~SDNPublisher</a> ()</td></tr>
<tr class="memdesc:a0dba4900f54dd5a27653c71c17ac3be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classMARTe_1_1SDNPublisher.html#a0dba4900f54dd5a27653c71c17ac3be8">More...</a><br /></td></tr>
<tr class="separator:a0dba4900f54dd5a27653c71c17ac3be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a7b3aa4c9dcb77d9b5f8d86e5fd7eb"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1SDNPublisher.html#ac1a7b3aa4c9dcb77d9b5f8d86e5fd7eb">Initialise</a> (StructuredDataI &amp;data)</td></tr>
<tr class="memdesc:ac1a7b3aa4c9dcb77d9b5f8d86e5fd7eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies and parses instance parameters.  <a href="classMARTe_1_1SDNPublisher.html#ac1a7b3aa4c9dcb77d9b5f8d86e5fd7eb">More...</a><br /></td></tr>
<tr class="separator:ac1a7b3aa4c9dcb77d9b5f8d86e5fd7eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f5d86e2364406920b85feadf5c5fa63"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1SDNPublisher.html#a6f5d86e2364406920b85feadf5c5fa63">SetConfiguredDatabase</a> (StructuredDataI &amp;data)</td></tr>
<tr class="memdesc:a6f5d86e2364406920b85feadf5c5fa63"><td class="mdescLeft">&#160;</td><td class="mdescRight">See DataSourceI::SetConfiguredDatabase.  <a href="classMARTe_1_1SDNPublisher.html#a6f5d86e2364406920b85feadf5c5fa63">More...</a><br /></td></tr>
<tr class="separator:a6f5d86e2364406920b85feadf5c5fa63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ddc08bbc7c1da302da63ca4343c61b8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1SDNPublisher.html#a9ddc08bbc7c1da302da63ca4343c61b8">AllocateMemory</a> ()</td></tr>
<tr class="memdesc:a9ddc08bbc7c1da302da63ca4343c61b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">See DataSourceI::AllocateMemory.  <a href="classMARTe_1_1SDNPublisher.html#a9ddc08bbc7c1da302da63ca4343c61b8">More...</a><br /></td></tr>
<tr class="separator:a9ddc08bbc7c1da302da63ca4343c61b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f6b6c8794cd3e284d338ebd74286ff"><td class="memItemLeft" align="right" valign="top">virtual uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1SDNPublisher.html#a95f6b6c8794cd3e284d338ebd74286ff">GetNumberOfMemoryBuffers</a> ()</td></tr>
<tr class="memdesc:a95f6b6c8794cd3e284d338ebd74286ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">See DataSourceI::GetNumberOfMemoryBuffers.  <a href="classMARTe_1_1SDNPublisher.html#a95f6b6c8794cd3e284d338ebd74286ff">More...</a><br /></td></tr>
<tr class="separator:a95f6b6c8794cd3e284d338ebd74286ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15122764799bf6e08ea249d09b2e2852"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1SDNPublisher.html#a15122764799bf6e08ea249d09b2e2852">GetSignalMemoryBuffer</a> (const uint32 signalIdx, const uint32 bufferIdx, void *&amp;signalAddress)</td></tr>
<tr class="memdesc:a15122764799bf6e08ea249d09b2e2852"><td class="mdescLeft">&#160;</td><td class="mdescRight">See DataSourceI::GetSignalMemoryBuffers.  <a href="classMARTe_1_1SDNPublisher.html#a15122764799bf6e08ea249d09b2e2852">More...</a><br /></td></tr>
<tr class="separator:a15122764799bf6e08ea249d09b2e2852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3bbe6419f1acdaa826ac85f80aebd3"><td class="memItemLeft" align="right" valign="top">virtual const char8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1SDNPublisher.html#a6d3bbe6419f1acdaa826ac85f80aebd3">GetBrokerName</a> (StructuredDataI &amp;data, const SignalDirection direction)</td></tr>
<tr class="memdesc:a6d3bbe6419f1acdaa826ac85f80aebd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">See DataSourceI::GetBrokerName.  <a href="classMARTe_1_1SDNPublisher.html#a6d3bbe6419f1acdaa826ac85f80aebd3">More...</a><br /></td></tr>
<tr class="separator:a6d3bbe6419f1acdaa826ac85f80aebd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad900a2bc7e82a142b6047bcd88fbc29c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1SDNPublisher.html#ad900a2bc7e82a142b6047bcd88fbc29c">GetInputBrokers</a> (ReferenceContainer &amp;inputBrokers, const char8 *const functionName, void *const gamMemPtr)</td></tr>
<tr class="memdesc:ad900a2bc7e82a142b6047bcd88fbc29c"><td class="mdescLeft">&#160;</td><td class="mdescRight">See DataSourceI::GetInputBrokers.  <a href="classMARTe_1_1SDNPublisher.html#ad900a2bc7e82a142b6047bcd88fbc29c">More...</a><br /></td></tr>
<tr class="separator:ad900a2bc7e82a142b6047bcd88fbc29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c390105b16e56043f4f67d7e8ec0cce"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1SDNPublisher.html#a9c390105b16e56043f4f67d7e8ec0cce">GetOutputBrokers</a> (ReferenceContainer &amp;outputBrokers, const char8 *const functionName, void *const gamMemPtr)</td></tr>
<tr class="memdesc:a9c390105b16e56043f4f67d7e8ec0cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">See DataSourceI::GetOutputBrokers.  <a href="classMARTe_1_1SDNPublisher.html#a9c390105b16e56043f4f67d7e8ec0cce">More...</a><br /></td></tr>
<tr class="separator:a9c390105b16e56043f4f67d7e8ec0cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cfedefd418a68bb98193bff7be812c3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1SDNPublisher.html#a7cfedefd418a68bb98193bff7be812c3">PrepareNextState</a> (const char8 *const currentStateName, const char8 *const nextStateName)</td></tr>
<tr class="memdesc:a7cfedefd418a68bb98193bff7be812c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">See DataSourceI::PrepareNextState.  <a href="classMARTe_1_1SDNPublisher.html#a7cfedefd418a68bb98193bff7be812c3">More...</a><br /></td></tr>
<tr class="separator:a7cfedefd418a68bb98193bff7be812c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa9e32178b6b3163f22a3bc418e6fa6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1SDNPublisher.html#a7fa9e32178b6b3163f22a3bc418e6fa6">Synchronise</a> ()</td></tr>
<tr class="memdesc:a7fa9e32178b6b3163f22a3bc418e6fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">See DataSourceI::Synchronise.  <a href="classMARTe_1_1SDNPublisher.html#a7fa9e32178b6b3163f22a3bc418e6fa6">More...</a><br /></td></tr>
<tr class="separator:a7fa9e32178b6b3163f22a3bc418e6fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A DataSource which collects and publishes signals over the ITER SDN. </p>
<p>The DataSource collects its inputs signals into a SDN topic and publishes the topic over the SDN network.</p>
<p>The SDN core library uses topic "name" as key to establish matching communication channels across all participants. Alternatively, the destination address required by the underlying transport may be defined explicitly, in which case matching topic names would only be used to support fault investigation purposes.</p>
<p>The configuration syntax is (signals names are only given as an example):</p>
<pre>
+Publisher = {
    Class = <a class="el" href="classMARTe_1_1SDNPublisher.html" title="A DataSource which collects and publishes signals over the ITER SDN.">SDNPublisher</a>
    Topic = name // The name is used to establish many-to-many communication channels
    Interface = name // The network interface name to be used
    Address = address:port // Optional - Explicit destination address
<b>ifdef</b> FEATURE_10840
    SourcePort = port // Optional - Explicit source-side port to bind to
    NetworkByteOrder = 1 // Optional - Enforce On-the-wire network byte ordering
<b>endif</b> Signals = {
        Header = { //Optional. If present (i.e. if there is a signal named header) the sent packet header will be copied into this field (note that it can be later decomposed by GAMs using Ranges). It shall be the first signal.
            Type = uint8
            NumberOfElements = 48 //Must match the SDN header size
        }
        Counter = {
            Type = uint64
        }
        Timestamp = {
            Type = uint64
        }
        Setpoint = { // The device control command elaborated within this RTApplication
            Type = double
        }
    }
}
</pre><p>The DataSource relies on a MemoryMap(Synchronised)OutputBroker to interface to GAM signals. The DataSource does not allocate memory, rather maps directly the signals to the SDN message payload directly. <b>ifdef</b> FEATURE_10840 The DataSource has additional optional parameters to override the default publisher-side source port and/or opt for publishing messages on the wire using network byte order. The valid range for source port is 0 || [1024, 65535]. The default on-the-wire byte order is the host native ordering (MemoryMapOutputBroker performs memory copies pf the signals directly to the message payload) and may be overridden to use network byte order, in which case the DataSource performs the necessary byte swaps before publication. <b>endif</b> </p>
<dl class="section warning"><dt>Warning</dt><dd>The DataSource requires that one and only one signal be identified as synchronisation point (i.e. only one signal must set Trigger = 1).</dd>
<dd>
the DataSource does not support signal samples batching.</dd>
<dd>
the data payload over the network is structured in the same way as the signal definition order. Interoperability between distributed participants require strict configuration control of the payload definition. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aafba07f4ab591c44f3efe5873a7671e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafba07f4ab591c44f3efe5873a7671e2">&#9670;&nbsp;</a></span>SDNPublisher()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MARTe::SDNPublisher::SDNPublisher </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<dl class="section post"><dt>Postcondition</dt><dd>topic = NULL_PTR &amp;&amp; publisher = NULL_PTR &amp;&amp; synchronising = false </dd></dl>

</div>
</div>
<a id="a0dba4900f54dd5a27653c71c17ac3be8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dba4900f54dd5a27653c71c17ac3be8">&#9670;&nbsp;</a></span>~SDNPublisher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MARTe::SDNPublisher::~SDNPublisher </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Releases resources. </p><dl class="section post"><dt>Postcondition</dt><dd>topic = NULL_PTR &amp;&amp; publisher = NULL_PTR </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9ddc08bbc7c1da302da63ca4343c61b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ddc08bbc7c1da302da63ca4343c61b8">&#9670;&nbsp;</a></span>AllocateMemory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::SDNPublisher::AllocateMemory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See DataSourceI::AllocateMemory. </p>
<p>The method instantiate a sdn::Topic and sdn::Publisher, and used the transport message buffer inside the sdn::Publisher as memory for input signals. </p><dl class="section return"><dt>Returns</dt><dd>false in case or exception inside the SDN core library. </dd></dl>

</div>
</div>
<a id="a6d3bbe6419f1acdaa826ac85f80aebd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d3bbe6419f1acdaa826ac85f80aebd3">&#9670;&nbsp;</a></span>GetBrokerName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char8 * MARTe::SDNPublisher::GetBrokerName </td>
          <td>(</td>
          <td class="paramtype">StructuredDataI &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SignalDirection&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See DataSourceI::GetBrokerName. </p>
<p>The implementation is associated to MemoryMapOutputBroker or MemoryMapSynchronisedOutputBroker depending on the signal properties. </p><dl class="section return"><dt>Returns</dt><dd>MemoryMapOutputBroker or MemoryMapSynchronisedOutputBroker for OutputSignals and MemoryMapInputBroker if the signal name is Header and the direction is InputSignals. </dd></dl>

</div>
</div>
<a id="ad900a2bc7e82a142b6047bcd88fbc29c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad900a2bc7e82a142b6047bcd88fbc29c">&#9670;&nbsp;</a></span>GetInputBrokers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::SDNPublisher::GetInputBrokers </td>
          <td>(</td>
          <td class="paramtype">ReferenceContainer &amp;&#160;</td>
          <td class="paramname"><em>inputBrokers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char8 *const&#160;</td>
          <td class="paramname"><em>functionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>gamMemPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See DataSourceI::GetInputBrokers. </p>
<p>Adds a MemoryMapInputBroker if the SDN Header is to be read, NOOP otherwise. </p><dl class="section return"><dt>Returns</dt><dd>true if the SDN Header is to be read, false otherwise. </dd></dl>

</div>
</div>
<a id="a95f6b6c8794cd3e284d338ebd74286ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f6b6c8794cd3e284d338ebd74286ff">&#9670;&nbsp;</a></span>GetNumberOfMemoryBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 MARTe::SDNPublisher::GetNumberOfMemoryBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See DataSourceI::GetNumberOfMemoryBuffers. </p>
<dl class="section return"><dt>Returns</dt><dd>1. </dd></dl>

</div>
</div>
<a id="a9c390105b16e56043f4f67d7e8ec0cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c390105b16e56043f4f67d7e8ec0cce">&#9670;&nbsp;</a></span>GetOutputBrokers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::SDNPublisher::GetOutputBrokers </td>
          <td>(</td>
          <td class="paramtype">ReferenceContainer &amp;&#160;</td>
          <td class="paramname"><em>outputBrokers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char8 *const&#160;</td>
          <td class="paramname"><em>functionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>gamMemPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See DataSourceI::GetOutputBrokers. </p>
<p>The implementation provides MemoryMapOutputBroker instances for non-synchronising GAMs, it provides both one MemoryMapOutputBroker and one MemoryMapSynchronisedOutputBroker for the synchronising GAM. </p><dl class="section return"><dt>Returns</dt><dd>true if the BrokerI::Init is successful. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The case where part of the GAM signals are non-synchronizing requires the non-synchronizing broker to be inserted before the synchronizing one in order to make sure all the signals are copied before the synchronisation is performed.</dd></dl>

</div>
</div>
<a id="a15122764799bf6e08ea249d09b2e2852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15122764799bf6e08ea249d09b2e2852">&#9670;&nbsp;</a></span>GetSignalMemoryBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::SDNPublisher::GetSignalMemoryBuffer </td>
          <td>(</td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>signalIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>bufferIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&amp;&#160;</td>
          <td class="paramname"><em>signalAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See DataSourceI::GetSignalMemoryBuffers. </p>
<p>The method maps signals directly to addresses within the SDN message payload. </p><dl class="section return"><dt>Returns</dt><dd>1. </dd></dl>

</div>
</div>
<a id="ac1a7b3aa4c9dcb77d9b5f8d86e5fd7eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1a7b3aa4c9dcb77d9b5f8d86e5fd7eb">&#9670;&nbsp;</a></span>Initialise()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::SDNPublisher::Initialise </td>
          <td>(</td>
          <td class="paramtype">StructuredDataI &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verifies and parses instance parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>configuration in the form: <pre>
+Publisher = {
    Class = <a class="el" href="classMARTe_1_1SDNPublisher.html" title="A DataSource which collects and publishes signals over the ITER SDN.">SDNPublisher</a>
    Topic = name // The name is used to establish many-to-many communication channels
    Interface = name // The network interface name to be used, e.g. eth0
    Address = address:port // Optional - Explicit destination address
}
</pre>  The configuration parameters are subject to the following criteria: The topic "name" is mandatory and can be any string. The "name" is used to associate the publisher to an address and must be identical on all participants. The mapping between topic "name" and address is done within the scope of the SDN core library and guaranteed to match between all participants using the same topic "name". Alternatively, the destination address can be explicitly defined using a topic "name" of the form 'sdn://address:port/name'; which is purposeful to establish e.g. a unicast connection. The interface "name" is mandatory and verified to correspond to a valid named interface on the host, e.g. eth0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the criteria above is met. </dd></dl>

</div>
</div>
<a id="a7cfedefd418a68bb98193bff7be812c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cfedefd418a68bb98193bff7be812c3">&#9670;&nbsp;</a></span>PrepareNextState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::SDNPublisher::PrepareNextState </td>
          <td>(</td>
          <td class="paramtype">const char8 *const&#160;</td>
          <td class="paramname"><em>currentStateName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char8 *const&#160;</td>
          <td class="paramname"><em>nextStateName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See DataSourceI::PrepareNextState. </p>
<dl class="section return"><dt>Returns</dt><dd>true. </dd></dl>

</div>
</div>
<a id="a6f5d86e2364406920b85feadf5c5fa63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f5d86e2364406920b85feadf5c5fa63">&#9670;&nbsp;</a></span>SetConfiguredDatabase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::SDNPublisher::SetConfiguredDatabase </td>
          <td>(</td>
          <td class="paramtype">StructuredDataI &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See DataSourceI::SetConfiguredDatabase. </p>
<p>The DataSource does not parse the attribute; rather, the method is overloaded to perform signal validity checks outside the scope of the later <a class="el" href="classMARTe_1_1SDNPublisher.html#a9ddc08bbc7c1da302da63ca4343c61b8" title="See DataSourceI::AllocateMemory.">SDNPublisher::AllocateMemory</a> which can be ensured that it is called with signal list previously validated. </p><dl class="section return"><dt>Returns</dt><dd>false in case no signals are being configured, or in case there is no or more than one signal declared as synchronisation point. </dd></dl>

</div>
</div>
<a id="a7fa9e32178b6b3163f22a3bc418e6fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa9e32178b6b3163f22a3bc418e6fa6">&#9670;&nbsp;</a></span>Synchronise()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::SDNPublisher::Synchronise </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See DataSourceI::Synchronise. </p>
<p>The method calls sdn::Publisher::Publish and relies on the fact that SDN message payload has been previously completely modified by the OutputBroker instances. </p><dl class="section warning"><dt>Warning</dt><dd>It is for the application-specific configuration to ensure and organise ordering of the GAMs so as to ensure proper payload update prior to publication, e.g. the synchronising GAM is scheduled after all the non-synchronising GAMs contributing signals to the DataSource. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true or false in case of error within the SDN core library. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/codac-dev/MARTe2Project/GIT/MARTe2-components/Source/Components/DataSources/SDN/<a class="el" href="SDNPublisher_8h_source.html">SDNPublisher.h</a></li>
<li>/home/codac-dev/MARTe2Project/GIT/MARTe2-components/Source/Components/DataSources/SDN/<a class="el" href="SDNPublisher_8cpp.html">SDNPublisher.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.0
</small></address>
</body>
</html>
