<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MARTe2-components: MARTe::SDNSubscriber Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MARTe2-components
   </div>
   <div id="projectbrief">C++ real-time application development framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>MARTe</b></li><li class="navelem"><a class="el" href="classMARTe_1_1SDNSubscriber.html">SDNSubscriber</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classMARTe_1_1SDNSubscriber-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MARTe::SDNSubscriber Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A DataSource which receives signals transported over the ITER SDN.  
 <a href="classMARTe_1_1SDNSubscriber.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="SDNSubscriber_8h_source.html">SDNSubscriber.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MARTe::SDNSubscriber:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classMARTe_1_1SDNSubscriber.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a42327f1beac7d9b76cd2dad02e0f3074"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1SDNSubscriber.html#a42327f1beac7d9b76cd2dad02e0f3074">SDNSubscriber</a> ()</td></tr>
<tr class="memdesc:a42327f1beac7d9b76cd2dad02e0f3074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classMARTe_1_1SDNSubscriber.html#a42327f1beac7d9b76cd2dad02e0f3074">More...</a><br /></td></tr>
<tr class="separator:a42327f1beac7d9b76cd2dad02e0f3074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07ef59f4474b9e508fcea9bab4239c1"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1SDNSubscriber.html#aa07ef59f4474b9e508fcea9bab4239c1">~SDNSubscriber</a> ()</td></tr>
<tr class="memdesc:aa07ef59f4474b9e508fcea9bab4239c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classMARTe_1_1SDNSubscriber.html#aa07ef59f4474b9e508fcea9bab4239c1">More...</a><br /></td></tr>
<tr class="separator:aa07ef59f4474b9e508fcea9bab4239c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1203e62dccf1886bf08cb638bf23faae"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1SDNSubscriber.html#a1203e62dccf1886bf08cb638bf23faae">Initialise</a> (StructuredDataI &amp;data)</td></tr>
<tr class="memdesc:a1203e62dccf1886bf08cb638bf23faae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies and parses instance parameters.  <a href="classMARTe_1_1SDNSubscriber.html#a1203e62dccf1886bf08cb638bf23faae">More...</a><br /></td></tr>
<tr class="separator:a1203e62dccf1886bf08cb638bf23faae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e2bc7612942db4b204a8c4409c0937"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1SDNSubscriber.html#a69e2bc7612942db4b204a8c4409c0937">SetConfiguredDatabase</a> (StructuredDataI &amp;data)</td></tr>
<tr class="memdesc:a69e2bc7612942db4b204a8c4409c0937"><td class="mdescLeft">&#160;</td><td class="mdescRight">See DataSourceI::SetConfiguredDatabase.  <a href="classMARTe_1_1SDNSubscriber.html#a69e2bc7612942db4b204a8c4409c0937">More...</a><br /></td></tr>
<tr class="separator:a69e2bc7612942db4b204a8c4409c0937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260a40b2ecbc28f0acc5525d0814e829"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1SDNSubscriber.html#a260a40b2ecbc28f0acc5525d0814e829">AllocateMemory</a> ()</td></tr>
<tr class="memdesc:a260a40b2ecbc28f0acc5525d0814e829"><td class="mdescLeft">&#160;</td><td class="mdescRight">See DataSourceI::AllocateMemory.  <a href="classMARTe_1_1SDNSubscriber.html#a260a40b2ecbc28f0acc5525d0814e829">More...</a><br /></td></tr>
<tr class="separator:a260a40b2ecbc28f0acc5525d0814e829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725299fc06e8592c131a365e8037e688"><td class="memItemLeft" align="right" valign="top">virtual uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1SDNSubscriber.html#a725299fc06e8592c131a365e8037e688">GetNumberOfMemoryBuffers</a> ()</td></tr>
<tr class="memdesc:a725299fc06e8592c131a365e8037e688"><td class="mdescLeft">&#160;</td><td class="mdescRight">See DataSourceI::GetNumberOfMemoryBuffers.  <a href="classMARTe_1_1SDNSubscriber.html#a725299fc06e8592c131a365e8037e688">More...</a><br /></td></tr>
<tr class="separator:a725299fc06e8592c131a365e8037e688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ce45ce4208ddc093e07abe86c7a51e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1SDNSubscriber.html#ad3ce45ce4208ddc093e07abe86c7a51e">GetSignalMemoryBuffer</a> (const uint32 signalIdx, const uint32 bufferIdx, void *&amp;signalAddress)</td></tr>
<tr class="memdesc:ad3ce45ce4208ddc093e07abe86c7a51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">See DataSourceI::GetSignalMemoryBuffers.  <a href="classMARTe_1_1SDNSubscriber.html#ad3ce45ce4208ddc093e07abe86c7a51e">More...</a><br /></td></tr>
<tr class="separator:ad3ce45ce4208ddc093e07abe86c7a51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9ccc34856f225bd7a8df4a9034567c"><td class="memItemLeft" align="right" valign="top">virtual const char8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1SDNSubscriber.html#aad9ccc34856f225bd7a8df4a9034567c">GetBrokerName</a> (StructuredDataI &amp;data, const SignalDirection direction)</td></tr>
<tr class="memdesc:aad9ccc34856f225bd7a8df4a9034567c"><td class="mdescLeft">&#160;</td><td class="mdescRight">See DataSourceI::GetBrokerName.  <a href="classMARTe_1_1SDNSubscriber.html#aad9ccc34856f225bd7a8df4a9034567c">More...</a><br /></td></tr>
<tr class="separator:aad9ccc34856f225bd7a8df4a9034567c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8a350a5dc3382d8c9f122ed395f8cf"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1SDNSubscriber.html#adc8a350a5dc3382d8c9f122ed395f8cf">GetInputBrokers</a> (ReferenceContainer &amp;inputBrokers, const char8 *const functionName, void *const gamMemPtr)</td></tr>
<tr class="memdesc:adc8a350a5dc3382d8c9f122ed395f8cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">See DataSourceI::GetInputBrokers.  <a href="classMARTe_1_1SDNSubscriber.html#adc8a350a5dc3382d8c9f122ed395f8cf">More...</a><br /></td></tr>
<tr class="separator:adc8a350a5dc3382d8c9f122ed395f8cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116f30276c4e3beed7842755b951f92f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1SDNSubscriber.html#a116f30276c4e3beed7842755b951f92f">GetOutputBrokers</a> (ReferenceContainer &amp;outputBrokers, const char8 *const functionName, void *const gamMemPtr)</td></tr>
<tr class="memdesc:a116f30276c4e3beed7842755b951f92f"><td class="mdescLeft">&#160;</td><td class="mdescRight">See DataSourceI::GetOutputBrokers.  <a href="classMARTe_1_1SDNSubscriber.html#a116f30276c4e3beed7842755b951f92f">More...</a><br /></td></tr>
<tr class="separator:a116f30276c4e3beed7842755b951f92f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341498f3c139edb9e9cbc96f5946b9b3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1SDNSubscriber.html#a341498f3c139edb9e9cbc96f5946b9b3">PrepareNextState</a> (const char8 *const currentStateName, const char8 *const nextStateName)</td></tr>
<tr class="memdesc:a341498f3c139edb9e9cbc96f5946b9b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">See DataSourceI::PrepareNextState.  <a href="classMARTe_1_1SDNSubscriber.html#a341498f3c139edb9e9cbc96f5946b9b3">More...</a><br /></td></tr>
<tr class="separator:a341498f3c139edb9e9cbc96f5946b9b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae503bdd0e9d4af037815ca5c3d0a9f36"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1SDNSubscriber.html#ae503bdd0e9d4af037815ca5c3d0a9f36">Synchronise</a> ()</td></tr>
<tr class="memdesc:ae503bdd0e9d4af037815ca5c3d0a9f36"><td class="mdescLeft">&#160;</td><td class="mdescRight">See DataSourceI::Synchronise.  <a href="classMARTe_1_1SDNSubscriber.html#ae503bdd0e9d4af037815ca5c3d0a9f36">More...</a><br /></td></tr>
<tr class="separator:ae503bdd0e9d4af037815ca5c3d0a9f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaec273ddf03eeaadd92f68e17fe7512"><td class="memItemLeft" align="right" valign="top">virtual ErrorManagement::ErrorType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1SDNSubscriber.html#aeaec273ddf03eeaadd92f68e17fe7512">Execute</a> (ExecutionInfo &amp;info)</td></tr>
<tr class="memdesc:aeaec273ddf03eeaadd92f68e17fe7512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function for an EmbeddedThread.  <a href="classMARTe_1_1SDNSubscriber.html#aeaec273ddf03eeaadd92f68e17fe7512">More...</a><br /></td></tr>
<tr class="separator:aeaec273ddf03eeaadd92f68e17fe7512"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A DataSource which receives signals transported over the ITER SDN. </p>
<p>The DataSource connects to the SDN network named interface and received topics with configurable blocking (with timeout) behaviour.</p>
<p>The SDN core library uses topic "name" as key to establish matching communication channels across all participants. Alternatively, the destination address required by the underlying transport may be defined explicitly, in which case matching topic names would only be used to support fault investigation purposes.</p>
<p>The configuration syntax is (signals names are only given as an example):</p>
<pre>
+Subscriber = {
    Class = <a class="el" href="classMARTe_1_1SDNSubscriber.html" title="A DataSource which receives signals transported over the ITER SDN.">SDNSubscriber</a>
    Topic = "name" // The name is used to establish many-to-many communication channels
    Interface = "name" // The network interface name to be used
    Address = address:port // Optional - Explicit destination address
    Timeout = timeout_in_ms // Optional - Used for synchronising mode semaphore
    CPUs = cpumask // Optional - Explicit affinity for the thread
    Signals = {
        Header = { //Optional. If present (i.e. if there is a signal named header) the received packet header will be copied into this field (note that it can be later decomposed by GAMs using Ranges). It shall be the first signal.
            Type = uint8
            NumberOfElements = 48 //Must match the SDN header size
        }
        Counter = {
            Type = uint64
        }
        Timestamp = {
            Type = uint64
        }
        Setpoint = { // The device control command received for use in this RTApplication
            Type = double
        }
    }
}
</pre><p>The DataSource relies on a MemoryMapInputBroker to interface to GAM signals. The DataSource does not allocate memory, rather maps directly the signals to the SDN message payload directly.</p>
<p>The DataSource can be used in asynchronous (caching) mode whereby the RT threads are synchronised with an alternative method and the <a class="el" href="classMARTe_1_1SDNSubscriber.html" title="A DataSource which receives signals transported over the ITER SDN.">SDNSubscriber</a> holds whichever signal samples were last received.</p>
<dl class="section warning"><dt>Warning</dt><dd>The DataSource does not support more than one signal identified as synchronisation point so as to ensure that the message payload is consistently provided to all GAMs associated to it. It does support however a signal 'caching' mode (non-synchronising) to cater for the cases where the application real-time threads are synchronised using an alternate source, in which case the DataSource only provides the last received payload,</dd>
<dd>
The DataSource does not support signal samples batching.</dd>
<dd>
The data payload over the network is structured in the same way as the signal definition order. Interoperability between distributed participants require strict configuration control of the payload definition. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a42327f1beac7d9b76cd2dad02e0f3074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42327f1beac7d9b76cd2dad02e0f3074">&#9670;&nbsp;</a></span>SDNSubscriber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MARTe::SDNSubscriber::SDNSubscriber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<dl class="section post"><dt>Postcondition</dt><dd>topic = NULL_PTR &amp;&amp; subscriber = NULL_PTR </dd></dl>

</div>
</div>
<a id="aa07ef59f4474b9e508fcea9bab4239c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa07ef59f4474b9e508fcea9bab4239c1">&#9670;&nbsp;</a></span>~SDNSubscriber()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MARTe::SDNSubscriber::~SDNSubscriber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Releases resources. </p><dl class="section post"><dt>Postcondition</dt><dd>topic = NULL_PTR &amp;&amp; subscriber = NULL_PTR </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a260a40b2ecbc28f0acc5525d0814e829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a260a40b2ecbc28f0acc5525d0814e829">&#9670;&nbsp;</a></span>AllocateMemory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::SDNSubscriber::AllocateMemory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See DataSourceI::AllocateMemory. </p>
<p>The method instantiate a sdn::Topic and sdn::Subscriber, and used the transport message buffer inside the sdn::Subscriber as memory for output signals. </p><dl class="section return"><dt>Returns</dt><dd>false in case or exception inside the SDN core library. </dd></dl>

</div>
</div>
<a id="aeaec273ddf03eeaadd92f68e17fe7512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaec273ddf03eeaadd92f68e17fe7512">&#9670;&nbsp;</a></span>Execute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ErrorManagement::ErrorType MARTe::SDNSubscriber::Execute </td>
          <td>(</td>
          <td class="paramtype">ExecutionInfo &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Callback function for an EmbeddedThread. </p>
<p>The method calls sdn::Subscriber::Receive and posts an EventSem to notify the Synchronise method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">info</td><td>not used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NoError if the EventSem can be successfully posted. </dd></dl>

</div>
</div>
<a id="aad9ccc34856f225bd7a8df4a9034567c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad9ccc34856f225bd7a8df4a9034567c">&#9670;&nbsp;</a></span>GetBrokerName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char8 * MARTe::SDNSubscriber::GetBrokerName </td>
          <td>(</td>
          <td class="paramtype">StructuredDataI &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SignalDirection&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See DataSourceI::GetBrokerName. </p>
<p>The implementation is associated to MemoryMapInputBroker or MemoryMapSynchronisedInputBroker depending on the signal properties. </p><dl class="section return"><dt>Returns</dt><dd>MemoryMapInputBroker or MemoryMapSynchronisedInputBroker. </dd></dl>

</div>
</div>
<a id="adc8a350a5dc3382d8c9f122ed395f8cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc8a350a5dc3382d8c9f122ed395f8cf">&#9670;&nbsp;</a></span>GetInputBrokers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::SDNSubscriber::GetInputBrokers </td>
          <td>(</td>
          <td class="paramtype">ReferenceContainer &amp;&#160;</td>
          <td class="paramname"><em>inputBrokers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char8 *const&#160;</td>
          <td class="paramname"><em>functionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>gamMemPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See DataSourceI::GetInputBrokers. </p>
<p>The implementation provides MemoryMapInputBroker instances for non-synchronising GAMs. it provides both one MemoryMapInputBroker and one MemoryMapSynchronisedInputBroker in case one synchronising GAM is declared. </p><dl class="section return"><dt>Returns</dt><dd>true if the BrokerI::Init is successful. </dd></dl>

</div>
</div>
<a id="a725299fc06e8592c131a365e8037e688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a725299fc06e8592c131a365e8037e688">&#9670;&nbsp;</a></span>GetNumberOfMemoryBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 MARTe::SDNSubscriber::GetNumberOfMemoryBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See DataSourceI::GetNumberOfMemoryBuffers. </p>
<dl class="section return"><dt>Returns</dt><dd>1. </dd></dl>

</div>
</div>
<a id="a116f30276c4e3beed7842755b951f92f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116f30276c4e3beed7842755b951f92f">&#9670;&nbsp;</a></span>GetOutputBrokers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::SDNSubscriber::GetOutputBrokers </td>
          <td>(</td>
          <td class="paramtype">ReferenceContainer &amp;&#160;</td>
          <td class="paramname"><em>outputBrokers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char8 *const&#160;</td>
          <td class="paramname"><em>functionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>gamMemPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See DataSourceI::GetOutputBrokers. </p>
<p>The implementation does not provide OutputBrokers. </p><dl class="section return"><dt>Returns</dt><dd>false. </dd></dl>

</div>
</div>
<a id="ad3ce45ce4208ddc093e07abe86c7a51e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3ce45ce4208ddc093e07abe86c7a51e">&#9670;&nbsp;</a></span>GetSignalMemoryBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::SDNSubscriber::GetSignalMemoryBuffer </td>
          <td>(</td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>signalIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>bufferIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&amp;&#160;</td>
          <td class="paramname"><em>signalAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See DataSourceI::GetSignalMemoryBuffers. </p>
<p>The method maps signals directly to addresses within the SDN message payload. </p><dl class="section return"><dt>Returns</dt><dd>1. </dd></dl>

</div>
</div>
<a id="a1203e62dccf1886bf08cb638bf23faae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1203e62dccf1886bf08cb638bf23faae">&#9670;&nbsp;</a></span>Initialise()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::SDNSubscriber::Initialise </td>
          <td>(</td>
          <td class="paramtype">StructuredDataI &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verifies and parses instance parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>configuration in the form: <pre>
+Subscriber = {
    Class = <a class="el" href="classMARTe_1_1SDNSubscriber.html" title="A DataSource which receives signals transported over the ITER SDN.">SDNSubscriber</a>
    Topic = "name" // The name is used to establish many-to-many communication channels
    Interface = "name" // The network interface name to be used, e.g. eth0
    Address = address:port // Optional - Explicit destination address
    CPUs = cpumask // Optional - Explicit affinity for the thread
}
</pre>  The configuration parameters are subject to the following criteria: The topic "name" is mandatory and can be any string. The "name" is used to associate the subscriber to an address and must be identical on all participants. The mapping between topic "name" and address is done within the scope of the SDN core library and guaranteed to match between all participants using the same topic "name". Alternatively, the destination address can be explicitly defined using a topic "name" of the form 'sdn://address:port/name'; which is purposeful to establish e.g. a unicast connection. The interface "name" is mandatory and verified to correspond to a valid named interface on the host, e.g. eth0. The DataSource operates in two modes, i.e. caching (the thread updates the signal memory with each received SDN message but the synchronisation of the RT thread is managed with an alternative mechanism) vs. synchronising behaviour (the activity of the RT thread is synchronised to the SDN reception). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The unicast behaviour is selected by means of specifying any destination address within the IPv4 unicast address range. The socket is bound to the named interface and the address is not used. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if the criteria is met. </dd></dl>

</div>
</div>
<a id="a341498f3c139edb9e9cbc96f5946b9b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a341498f3c139edb9e9cbc96f5946b9b3">&#9670;&nbsp;</a></span>PrepareNextState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::SDNSubscriber::PrepareNextState </td>
          <td>(</td>
          <td class="paramtype">const char8 *const&#160;</td>
          <td class="paramname"><em>currentStateName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char8 *const&#160;</td>
          <td class="paramname"><em>nextStateName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See DataSourceI::PrepareNextState. </p>
<p>The method empties the receive buffer and starts the embedded thread before returning. </p><dl class="section return"><dt>Returns</dt><dd>true or false if sdn::Subscriber has not been instantiated. </dd></dl>

</div>
</div>
<a id="a69e2bc7612942db4b204a8c4409c0937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e2bc7612942db4b204a8c4409c0937">&#9670;&nbsp;</a></span>SetConfiguredDatabase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::SDNSubscriber::SetConfiguredDatabase </td>
          <td>(</td>
          <td class="paramtype">StructuredDataI &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See DataSourceI::SetConfiguredDatabase. </p>
<p>The DataSource does not parse the <em>data</em> attribute; rather, the method is overloaded to perform signal validity checks outside the scope of the later <a class="el" href="classMARTe_1_1SDNSubscriber.html#a260a40b2ecbc28f0acc5525d0814e829" title="See DataSourceI::AllocateMemory.">SDNSubscriber::AllocateMemory</a> which can be ensured that it is called with signal list previously validated. </p><dl class="section return"><dt>Returns</dt><dd>false in case no signals are being configured. </dd></dl>

</div>
</div>
<a id="ae503bdd0e9d4af037815ca5c3d0a9f36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae503bdd0e9d4af037815ca5c3d0a9f36">&#9670;&nbsp;</a></span>Synchronise()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::SDNSubscriber::Synchronise </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See DataSourceI::Synchronise. </p>
<p>The method waits for a synchronisation semaphore which is posted by the EmbeddedThread upon successful message reception. </p><dl class="section return"><dt>Returns</dt><dd>true or false in case of error within the SDN core library. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/codac-dev/MARTe2Project/GIT/MARTe2-components/Source/Components/DataSources/SDN/<a class="el" href="SDNSubscriber_8h_source.html">SDNSubscriber.h</a></li>
<li>/home/codac-dev/MARTe2Project/GIT/MARTe2-components/Source/Components/DataSources/SDN/<a class="el" href="SDNSubscriber_8cpp.html">SDNSubscriber.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.0
</small></address>
</body>
</html>
