<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MARTe2-components: MARTe::DANSource Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MARTe2-components
   </div>
   <div id="projectbrief">C++ real-time application development framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>MARTe</b></li><li class="navelem"><a class="el" href="classMARTe_1_1DANSource.html">DANSource</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classMARTe_1_1DANSource-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MARTe::DANSource Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A DataSourceI which allows to store signals in an ITER DAN database.  
 <a href="classMARTe_1_1DANSource.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="DANSource_8h_source.html">DANSource.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MARTe::DANSource:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classMARTe_1_1DANSource.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a46b66e360ed10b1b2b892b6821375b70"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1DANSource.html#a46b66e360ed10b1b2b892b6821375b70">DANSource</a> ()</td></tr>
<tr class="memdesc:a46b66e360ed10b1b2b892b6821375b70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classMARTe_1_1DANSource.html#a46b66e360ed10b1b2b892b6821375b70">More...</a><br /></td></tr>
<tr class="separator:a46b66e360ed10b1b2b892b6821375b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae608bee7bb3252fc40a8b8e90c0b7e38"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1DANSource.html#ae608bee7bb3252fc40a8b8e90c0b7e38">~DANSource</a> ()</td></tr>
<tr class="memdesc:ae608bee7bb3252fc40a8b8e90c0b7e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classMARTe_1_1DANSource.html#ae608bee7bb3252fc40a8b8e90c0b7e38">More...</a><br /></td></tr>
<tr class="separator:ae608bee7bb3252fc40a8b8e90c0b7e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1234c88365b7afd2605099f0cda26928"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1DANSource.html#a1234c88365b7afd2605099f0cda26928">AllocateMemory</a> ()</td></tr>
<tr class="memdesc:a1234c88365b7afd2605099f0cda26928"><td class="mdescLeft">&#160;</td><td class="mdescRight">See DataSourceI::AllocateMemory.  <a href="classMARTe_1_1DANSource.html#a1234c88365b7afd2605099f0cda26928">More...</a><br /></td></tr>
<tr class="separator:a1234c88365b7afd2605099f0cda26928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e86f229e666c904c263633d7957147"><td class="memItemLeft" align="right" valign="top">virtual uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1DANSource.html#a65e86f229e666c904c263633d7957147">GetNumberOfMemoryBuffers</a> ()</td></tr>
<tr class="memdesc:a65e86f229e666c904c263633d7957147"><td class="mdescLeft">&#160;</td><td class="mdescRight">See DataSourceI::GetNumberOfMemoryBuffers.  <a href="classMARTe_1_1DANSource.html#a65e86f229e666c904c263633d7957147">More...</a><br /></td></tr>
<tr class="separator:a65e86f229e666c904c263633d7957147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d99cdf1b9b83cbfa3061de8c53e519"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1DANSource.html#a59d99cdf1b9b83cbfa3061de8c53e519">GetSignalMemoryBuffer</a> (const uint32 signalIdx, const uint32 bufferIdx, void *&amp;signalAddress)</td></tr>
<tr class="memdesc:a59d99cdf1b9b83cbfa3061de8c53e519"><td class="mdescLeft">&#160;</td><td class="mdescRight">See DataSourceI::GetSignalMemoryBuffer.  <a href="classMARTe_1_1DANSource.html#a59d99cdf1b9b83cbfa3061de8c53e519">More...</a><br /></td></tr>
<tr class="separator:a59d99cdf1b9b83cbfa3061de8c53e519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc889faa80e2d6f56e7194462cad1e1f"><td class="memItemLeft" align="right" valign="top">virtual const char8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1DANSource.html#adc889faa80e2d6f56e7194462cad1e1f">GetBrokerName</a> (StructuredDataI &amp;data, const SignalDirection direction)</td></tr>
<tr class="memdesc:adc889faa80e2d6f56e7194462cad1e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">See DataSourceI::GetNumberOfMemoryBuffers.  <a href="classMARTe_1_1DANSource.html#adc889faa80e2d6f56e7194462cad1e1f">More...</a><br /></td></tr>
<tr class="separator:adc889faa80e2d6f56e7194462cad1e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a05262c6656198d6630a3305d8ceb6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1DANSource.html#a97a05262c6656198d6630a3305d8ceb6">GetInputBrokers</a> (ReferenceContainer &amp;inputBrokers, const char8 *const functionName, void *const gamMemPtr)</td></tr>
<tr class="memdesc:a97a05262c6656198d6630a3305d8ceb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">See DataSourceI::GetInputBrokers.  <a href="classMARTe_1_1DANSource.html#a97a05262c6656198d6630a3305d8ceb6">More...</a><br /></td></tr>
<tr class="separator:a97a05262c6656198d6630a3305d8ceb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a65856adff49274bff253d8b01483ca"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1DANSource.html#a2a65856adff49274bff253d8b01483ca">GetOutputBrokers</a> (ReferenceContainer &amp;outputBrokers, const char8 *const functionName, void *const gamMemPtr)</td></tr>
<tr class="memdesc:a2a65856adff49274bff253d8b01483ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">See DataSourceI::GetOutputBrokers.  <a href="classMARTe_1_1DANSource.html#a2a65856adff49274bff253d8b01483ca">More...</a><br /></td></tr>
<tr class="separator:a2a65856adff49274bff253d8b01483ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f075b6d782426933be7e9c018a0f916"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1DANSource.html#a5f075b6d782426933be7e9c018a0f916">Synchronise</a> ()</td></tr>
<tr class="memdesc:a5f075b6d782426933be7e9c018a0f916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls PutData on all the <a class="el" href="classMARTe_1_1DANStream.html" title="Wraps a DAN stream (see dan_publisher_openStream).">DANStream</a> instances.  <a href="classMARTe_1_1DANSource.html#a5f075b6d782426933be7e9c018a0f916">More...</a><br /></td></tr>
<tr class="separator:a5f075b6d782426933be7e9c018a0f916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca3743c7f6a9b3e77a831145ed3802b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1DANSource.html#acca3743c7f6a9b3e77a831145ed3802b">PrepareNextState</a> (const char8 *const currentStateName, const char8 *const nextStateName)</td></tr>
<tr class="memdesc:acca3743c7f6a9b3e77a831145ed3802b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <a class="el" href="classMARTe_1_1DANStream.html#a522dab7938d6a75776deb9a00c3d511a" title="Resets the counter used by PutData.">DANStream::Reset</a> on all the <a class="el" href="classMARTe_1_1DANStream.html" title="Wraps a DAN stream (see dan_publisher_openStream).">DANStream</a> instances.  <a href="classMARTe_1_1DANSource.html#acca3743c7f6a9b3e77a831145ed3802b">More...</a><br /></td></tr>
<tr class="separator:acca3743c7f6a9b3e77a831145ed3802b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9f4bffc54f6406decf6a439d31e972"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1DANSource.html#aea9f4bffc54f6406decf6a439d31e972">Initialise</a> (StructuredDataI &amp;data)</td></tr>
<tr class="memdesc:aea9f4bffc54f6406decf6a439d31e972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads and verifies the configuration parameters detailed in the class description.  <a href="classMARTe_1_1DANSource.html#aea9f4bffc54f6406decf6a439d31e972">More...</a><br /></td></tr>
<tr class="separator:aea9f4bffc54f6406decf6a439d31e972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd35ab92e9079c34a340dbfc8b58b41e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1DANSource.html#abd35ab92e9079c34a340dbfc8b58b41e">SetConfiguredDatabase</a> (StructuredDataI &amp;data)</td></tr>
<tr class="memdesc:abd35ab92e9079c34a340dbfc8b58b41e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Final verification of all the parameters and setup of the <a class="el" href="classMARTe_1_1DANStream.html" title="Wraps a DAN stream (see dan_publisher_openStream).">DANStream</a> instances.  <a href="classMARTe_1_1DANSource.html#abd35ab92e9079c34a340dbfc8b58b41e">More...</a><br /></td></tr>
<tr class="separator:abd35ab92e9079c34a340dbfc8b58b41e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70c3b960e6a0bb25259d18117273d9b"><td class="memItemLeft" align="right" valign="top">ErrorManagement::ErrorType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1DANSource.html#ab70c3b960e6a0bb25259d18117273d9b">OpenStream</a> ()</td></tr>
<tr class="memdesc:ab70c3b960e6a0bb25259d18117273d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls dan_publisher_openStream on every <a class="el" href="classMARTe_1_1DANStream.html" title="Wraps a DAN stream (see dan_publisher_openStream).">DANStream</a>.  <a href="classMARTe_1_1DANSource.html#ab70c3b960e6a0bb25259d18117273d9b">More...</a><br /></td></tr>
<tr class="separator:ab70c3b960e6a0bb25259d18117273d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfcc33db94273132ebcb5ee1c5cf472a"><td class="memItemLeft" align="right" valign="top">ErrorManagement::ErrorType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1DANSource.html#abfcc33db94273132ebcb5ee1c5cf472a">CloseStream</a> ()</td></tr>
<tr class="memdesc:abfcc33db94273132ebcb5ee1c5cf472a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls dan_publisher_closeStream on every <a class="el" href="classMARTe_1_1DANStream.html" title="Wraps a DAN stream (see dan_publisher_openStream).">DANStream</a>.  <a href="classMARTe_1_1DANSource.html#abfcc33db94273132ebcb5ee1c5cf472a">More...</a><br /></td></tr>
<tr class="separator:abfcc33db94273132ebcb5ee1c5cf472a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942d892d3d472de06320c97c310d0fb3"><td class="memItemLeft" align="right" valign="top">const ProcessorType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1DANSource.html#a942d892d3d472de06320c97c310d0fb3">GetCPUMask</a> () const</td></tr>
<tr class="memdesc:a942d892d3d472de06320c97c310d0fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the affinity of the thread which is going to be used to asynchronously store the data in the DAN database.  <a href="classMARTe_1_1DANSource.html#a942d892d3d472de06320c97c310d0fb3">More...</a><br /></td></tr>
<tr class="separator:a942d892d3d472de06320c97c310d0fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4471f9775520440c821bf457bdff6d5"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1DANSource.html#ab4471f9775520440c821bf457bdff6d5">GetNumberOfBuffers</a> () const</td></tr>
<tr class="memdesc:ab4471f9775520440c821bf457bdff6d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of buffers in the circular buffer.  <a href="classMARTe_1_1DANSource.html#ab4471f9775520440c821bf457bdff6d5">More...</a><br /></td></tr>
<tr class="separator:ab4471f9775520440c821bf457bdff6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46368537ad88922a22d20f4f6a8a9cec"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1DANSource.html#a46368537ad88922a22d20f4f6a8a9cec">GetNumberOfPostTriggers</a> () const</td></tr>
<tr class="memdesc:a46368537ad88922a22d20f4f6a8a9cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of post configured buffers in the circular buffer.  <a href="classMARTe_1_1DANSource.html#a46368537ad88922a22d20f4f6a8a9cec">More...</a><br /></td></tr>
<tr class="separator:a46368537ad88922a22d20f4f6a8a9cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ea32741208822b9ccb7ed638cb9249"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1DANSource.html#a69ea32741208822b9ccb7ed638cb9249">GetNumberOfPreTriggers</a> () const</td></tr>
<tr class="memdesc:a69ea32741208822b9ccb7ed638cb9249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of pre configured buffers in the circular buffer.  <a href="classMARTe_1_1DANSource.html#a69ea32741208822b9ccb7ed638cb9249">More...</a><br /></td></tr>
<tr class="separator:a69ea32741208822b9ccb7ed638cb9249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a2837a41f9c080d47d1d2ce7345a56"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1DANSource.html#a49a2837a41f9c080d47d1d2ce7345a56">GetStackSize</a> () const</td></tr>
<tr class="memdesc:a49a2837a41f9c080d47d1d2ce7345a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the stack size of the thread which is going to be used to asynchronously store the data in the DAN database.  <a href="classMARTe_1_1DANSource.html#a49a2837a41f9c080d47d1d2ce7345a56">More...</a><br /></td></tr>
<tr class="separator:a49a2837a41f9c080d47d1d2ce7345a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34586b6808ae3067c5b01cf5fcd0480"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1DANSource.html#ab34586b6808ae3067c5b01cf5fcd0480">IsStoreOnTrigger</a> () const</td></tr>
<tr class="memdesc:ab34586b6808ae3067c5b01cf5fcd0480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the data is going to be stored in DAN is based on the occurrence of an external trigger.  <a href="classMARTe_1_1DANSource.html#ab34586b6808ae3067c5b01cf5fcd0480">More...</a><br /></td></tr>
<tr class="separator:ab34586b6808ae3067c5b01cf5fcd0480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f524266d2d499dd61c612e89f73a9a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1DANSource.html#a29f524266d2d499dd61c612e89f73a9a">IsAbsoluteTime</a> () const</td></tr>
<tr class="memdesc:a29f524266d2d499dd61c612e89f73a9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks is AbsoluteTime = 1 was set in the configuration entry.  <a href="classMARTe_1_1DANSource.html#a29f524266d2d499dd61c612e89f73a9a">More...</a><br /></td></tr>
<tr class="separator:a29f524266d2d499dd61c612e89f73a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ebb39d3e8302e07fec2a416d6ef164b"><td class="memItemLeft" align="right" valign="top">int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1DANSource.html#a0ebb39d3e8302e07fec2a416d6ef164b">GetTimeSignalIdx</a> () const</td></tr>
<tr class="memdesc:a0ebb39d3e8302e07fec2a416d6ef164b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the signal which is going to provide the time if the data is based on an external trigger.  <a href="classMARTe_1_1DANSource.html#a0ebb39d3e8302e07fec2a416d6ef164b">More...</a><br /></td></tr>
<tr class="separator:a0ebb39d3e8302e07fec2a416d6ef164b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902eb6f18a8a58fc7a6ca32e70964d93"><td class="memItemLeft" align="right" valign="top">uint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1DANSource.html#a902eb6f18a8a58fc7a6ca32e70964d93">GetAbsoluteStartTime</a> () const</td></tr>
<tr class="memdesc:a902eb6f18a8a58fc7a6ca32e70964d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the latest set absolute start time in nano-seconds (see PrepareNextState)  <a href="classMARTe_1_1DANSource.html#a902eb6f18a8a58fc7a6ca32e70964d93">More...</a><br /></td></tr>
<tr class="separator:a902eb6f18a8a58fc7a6ca32e70964d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d79c92b19d36a111af7aab0924b5f0"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1DANSource.html#a15d79c92b19d36a111af7aab0924b5f0">GetDANBufferMultiplier</a> () const</td></tr>
<tr class="memdesc:a15d79c92b19d36a111af7aab0924b5f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of buffers that the dan_publisher_publishSource_withDAQBuffer will use to buffer the data written by the DataSourceI.  <a href="classMARTe_1_1DANSource.html#a15d79c92b19d36a111af7aab0924b5f0">More...</a><br /></td></tr>
<tr class="separator:a15d79c92b19d36a111af7aab0924b5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A DataSourceI which allows to store signals in an ITER DAN database. </p>
<p>Data written into this data source is temporarily stored in a circular buffer and asynchronously flushed to the DAN database in the context of a separate thread. This circular buffer can either be continuously stored or stored only when a given event occurs (see StoreOnTrigger below).</p>
<p>This DataSourceI has the functions OpenStream and CloseStream registered as an RPC.</p>
<p>The configuration syntax is (names are only given as an example): </p><pre>
+DANSource_0 = {
    Class = DAN::DANSource
    NumberOfBuffers = 10 //Compulsory. Number of buffers in the circular buffer defined above. Each buffer is capable of holding a copy of all the DataSourceI signals.
    CPUMask = 15 //Compulsory. Affinity assigned to the threads responsible for asynchronously flush data into the DAN database.
    StackSize = 10000000 //Compulsory. Stack size of the thread above.
    DanBufferMultiplier = 4 //Compulsory. Number of buffers that the dan_publisher_publishSource_withDAQBuffer will use to buffer the data written by the DataSourceI
    StoreOnTrigger = 1 //Compulsory. If 0 all the data in the circular buffer is continuously stored. If 1 data is stored when the Trigger signal is 1 (see below).
    NumberOfPreTriggers = 2 //Compulsory iff StoreOnTrigger = 1.  Number of cycles to store before the trigger.
    NumberOfPostTriggers = 1 //Compulsory iff StoreOnTrigger = 1.  Number of cycles to store after the trigger.
    ICProgName = "MARTeApp.ex" //Optional. If set it will call dan_initLibrary_icprog with the specified name.

    Signals = {
        Trigger = { //Compulsory when StoreOnTrigger = 1. Must be set in index 0 of the Signals node. When the value of this signal is 1 data will be stored into the DAN database. Shall not be added if StoreOnTrigger = 0.
            Type = 'uint8" //Type must be uint8
        }
        Time = { //Compulsory when StoreOnTrigger = 1. Can be stored in any index, but TimeSignal must be set = 1. Shall not be added if StoreOnTrigger = 0.
            Type = "uint32" //Type must be uint32, int32, uint64 or int64
            TimeSignal = 1 //When set, this signal will be considered as the time source against which all signals will be stored.
                           //When not set (i.e. when no TimeSignal is defined) the time will computed as the absolute time at the latest state change (given by tcn_get_time) + the number of cycles multiplied by the signal Period (or 1/SamplingFrequency)
            AbsoluteTime = 0 //Optional. If 1 the Type shall be uint64 or int64 and the absolute time given by this signal will be used to time stamp the samples.
                             //          If 0 and TimeSignal = 1 the time will computed as the absolute time at the latest state change (given by tcn_get_time) + the time given by this time signal (which is assumed to be relative).
        }
        SignalUInt16F = { //As many as required.
            Period = 1e-3 //Compulsory if SamplingFrequency not set. Period between signal samples.
            SamplingFrequency = 1000 //Compulsory if Period not set. 1/Period between signal samples.
        }
        ...
    }
}
</pre><p> A <a class="el" href="classMARTe_1_1DANStream.html" title="Wraps a DAN stream (see dan_publisher_openStream).">DANStream</a> instance will be created for every different signal_type/sampling_frequency pair. Signals must be listed in the same order as they appear on the DAN xml. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a46b66e360ed10b1b2b892b6821375b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b66e360ed10b1b2b892b6821375b70">&#9670;&nbsp;</a></span>DANSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MARTe::DANSource::DANSource </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Initialises all the optional parameters as described in the class description. Registers the RPC OpenStream and CloseStream callback functions. </p>

</div>
</div>
<a id="ae608bee7bb3252fc40a8b8e90c0b7e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae608bee7bb3252fc40a8b8e90c0b7e38">&#9670;&nbsp;</a></span>~DANSource()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MARTe::DANSource::~DANSource </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Closes all the <a class="el" href="classMARTe_1_1DANStream.html" title="Wraps a DAN stream (see dan_publisher_openStream).">DANStream</a> instances. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1234c88365b7afd2605099f0cda26928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1234c88365b7afd2605099f0cda26928">&#9670;&nbsp;</a></span>AllocateMemory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::DANSource::AllocateMemory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See DataSourceI::AllocateMemory. </p>
<p>NOOP. </p><dl class="section return"><dt>Returns</dt><dd>true. </dd></dl>

</div>
</div>
<a id="abfcc33db94273132ebcb5ee1c5cf472a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfcc33db94273132ebcb5ee1c5cf472a">&#9670;&nbsp;</a></span>CloseStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ErrorManagement::ErrorType MARTe::DANSource::CloseStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls dan_publisher_closeStream on every <a class="el" href="classMARTe_1_1DANStream.html" title="Wraps a DAN stream (see dan_publisher_openStream).">DANStream</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>true if all dan_publisher_closeStream return 0. </dd></dl>

</div>
</div>
<a id="a902eb6f18a8a58fc7a6ca32e70964d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a902eb6f18a8a58fc7a6ca32e70964d93">&#9670;&nbsp;</a></span>GetAbsoluteStartTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64 MARTe::DANSource::GetAbsoluteStartTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the latest set absolute start time in nano-seconds (see PrepareNextState) </p>
<dl class="section return"><dt>Returns</dt><dd>the latest set absolute start time in nano-seconds </dd></dl>

</div>
</div>
<a id="adc889faa80e2d6f56e7194462cad1e1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc889faa80e2d6f56e7194462cad1e1f">&#9670;&nbsp;</a></span>GetBrokerName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char8 * MARTe::DANSource::GetBrokerName </td>
          <td>(</td>
          <td class="paramtype">StructuredDataI &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SignalDirection&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See DataSourceI::GetNumberOfMemoryBuffers. </p>
<p>Only OutputSignals are supported. </p><dl class="section return"><dt>Returns</dt><dd>MemoryMapAsyncOutputBroker if storeOnTrigger == 0, MemoryMapAsyncTriggerOutputBroker otherwise. </dd></dl>

</div>
</div>
<a id="a942d892d3d472de06320c97c310d0fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a942d892d3d472de06320c97c310d0fb3">&#9670;&nbsp;</a></span>GetCPUMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const ProcessorType &amp; MARTe::DANSource::GetCPUMask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the affinity of the thread which is going to be used to asynchronously store the data in the DAN database. </p>
<dl class="section return"><dt>Returns</dt><dd>the affinity of the thread which is going to be used to asynchronously store the data in the DAN database. </dd></dl>

</div>
</div>
<a id="a15d79c92b19d36a111af7aab0924b5f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15d79c92b19d36a111af7aab0924b5f0">&#9670;&nbsp;</a></span>GetDANBufferMultiplier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 MARTe::DANSource::GetDANBufferMultiplier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of buffers that the dan_publisher_publishSource_withDAQBuffer will use to buffer the data written by the DataSourceI. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of buffers that the dan_publisher_publishSource_withDAQBuffer will use . </dd></dl>

</div>
</div>
<a id="a97a05262c6656198d6630a3305d8ceb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a05262c6656198d6630a3305d8ceb6">&#9670;&nbsp;</a></span>GetInputBrokers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::DANSource::GetInputBrokers </td>
          <td>(</td>
          <td class="paramtype">ReferenceContainer &amp;&#160;</td>
          <td class="paramname"><em>inputBrokers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char8 *const&#160;</td>
          <td class="paramname"><em>functionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>gamMemPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See DataSourceI::GetInputBrokers. </p>
<dl class="section return"><dt>Returns</dt><dd>false. </dd></dl>

</div>
</div>
<a id="ab4471f9775520440c821bf457bdff6d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4471f9775520440c821bf457bdff6d5">&#9670;&nbsp;</a></span>GetNumberOfBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 MARTe::DANSource::GetNumberOfBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of buffers in the circular buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of buffers in the circular buffer. </dd></dl>

</div>
</div>
<a id="a65e86f229e666c904c263633d7957147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e86f229e666c904c263633d7957147">&#9670;&nbsp;</a></span>GetNumberOfMemoryBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 MARTe::DANSource::GetNumberOfMemoryBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See DataSourceI::GetNumberOfMemoryBuffers. </p>
<dl class="section return"><dt>Returns</dt><dd>1. </dd></dl>

</div>
</div>
<a id="a46368537ad88922a22d20f4f6a8a9cec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46368537ad88922a22d20f4f6a8a9cec">&#9670;&nbsp;</a></span>GetNumberOfPostTriggers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 MARTe::DANSource::GetNumberOfPostTriggers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of post configured buffers in the circular buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of post configured buffers in the circular buffer. </dd></dl>

</div>
</div>
<a id="a69ea32741208822b9ccb7ed638cb9249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69ea32741208822b9ccb7ed638cb9249">&#9670;&nbsp;</a></span>GetNumberOfPreTriggers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 MARTe::DANSource::GetNumberOfPreTriggers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of pre configured buffers in the circular buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of pre configured buffers in the circular buffer. </dd></dl>

</div>
</div>
<a id="a2a65856adff49274bff253d8b01483ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a65856adff49274bff253d8b01483ca">&#9670;&nbsp;</a></span>GetOutputBrokers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::DANSource::GetOutputBrokers </td>
          <td>(</td>
          <td class="paramtype">ReferenceContainer &amp;&#160;</td>
          <td class="paramname"><em>outputBrokers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char8 *const&#160;</td>
          <td class="paramname"><em>functionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>gamMemPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See DataSourceI::GetOutputBrokers. </p>
<p>If storeOnTrigger == 0 it adds a MemoryMapAsyncOutputBroker instance to the inputBrokers, otherwise it adds a MemoryMapAsyncTriggerOutputBroker instance to the outputBrokers. </p><dl class="section pre"><dt>Precondition</dt><dd>GetNumberOfFunctions() == 1u </dd></dl>

</div>
</div>
<a id="a59d99cdf1b9b83cbfa3061de8c53e519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d99cdf1b9b83cbfa3061de8c53e519">&#9670;&nbsp;</a></span>GetSignalMemoryBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::DANSource::GetSignalMemoryBuffer </td>
          <td>(</td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>signalIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>bufferIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&amp;&#160;</td>
          <td class="paramname"><em>signalAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See DataSourceI::GetSignalMemoryBuffer. </p>
<dl class="section pre"><dt>Precondition</dt><dd>SetConfiguredDatabase </dd></dl>

</div>
</div>
<a id="a49a2837a41f9c080d47d1d2ce7345a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a2837a41f9c080d47d1d2ce7345a56">&#9670;&nbsp;</a></span>GetStackSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 MARTe::DANSource::GetStackSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the stack size of the thread which is going to be used to asynchronously store the data in the DAN database. </p>
<dl class="section return"><dt>Returns</dt><dd>the stack size of the thread which is going to be used to asynchronously store the data in the DAN database. </dd></dl>

</div>
</div>
<a id="a0ebb39d3e8302e07fec2a416d6ef164b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ebb39d3e8302e07fec2a416d6ef164b">&#9670;&nbsp;</a></span>GetTimeSignalIdx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32 MARTe::DANSource::GetTimeSignalIdx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the signal which is going to provide the time if the data is based on an external trigger. </p>
<dl class="section return"><dt>Returns</dt><dd>the index of the signal which is going to provide the time if the data is based on an external trigger. </dd></dl>

</div>
</div>
<a id="aea9f4bffc54f6406decf6a439d31e972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea9f4bffc54f6406decf6a439d31e972">&#9670;&nbsp;</a></span>Initialise()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::DANSource::Initialise </td>
          <td>(</td>
          <td class="paramtype">StructuredDataI &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads and verifies the configuration parameters detailed in the class description. </p>
<dl class="section return"><dt>Returns</dt><dd>true if all the mandatory parameters are correctly specified and if the specified optional parameters have valid values. </dd></dl>

</div>
</div>
<a id="a29f524266d2d499dd61c612e89f73a9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f524266d2d499dd61c612e89f73a9a">&#9670;&nbsp;</a></span>IsAbsoluteTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::DANSource::IsAbsoluteTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks is AbsoluteTime = 1 was set in the configuration entry. </p>
<dl class="section return"><dt>Returns</dt><dd>true if AbsoluteTime = 1 was set in the TimeSignal of the configuration entry. </dd></dl>

</div>
</div>
<a id="ab34586b6808ae3067c5b01cf5fcd0480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34586b6808ae3067c5b01cf5fcd0480">&#9670;&nbsp;</a></span>IsStoreOnTrigger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::DANSource::IsStoreOnTrigger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the data is going to be stored in DAN is based on the occurrence of an external trigger. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the data is going to be stored in DAN is based on a trigger event. </dd></dl>

</div>
</div>
<a id="ab70c3b960e6a0bb25259d18117273d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab70c3b960e6a0bb25259d18117273d9b">&#9670;&nbsp;</a></span>OpenStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ErrorManagement::ErrorType MARTe::DANSource::OpenStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls dan_publisher_openStream on every <a class="el" href="classMARTe_1_1DANStream.html" title="Wraps a DAN stream (see dan_publisher_openStream).">DANStream</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>true if all dan_publisher_openStream return &gt;= 0. </dd></dl>

</div>
</div>
<a id="acca3743c7f6a9b3e77a831145ed3802b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acca3743c7f6a9b3e77a831145ed3802b">&#9670;&nbsp;</a></span>PrepareNextState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::DANSource::PrepareNextState </td>
          <td>(</td>
          <td class="paramtype">const char8 *const&#160;</td>
          <td class="paramname"><em>currentStateName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char8 *const&#160;</td>
          <td class="paramname"><em>nextStateName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls <a class="el" href="classMARTe_1_1DANStream.html#a522dab7938d6a75776deb9a00c3d511a" title="Resets the counter used by PutData.">DANStream::Reset</a> on all the <a class="el" href="classMARTe_1_1DANStream.html" title="Wraps a DAN stream (see dan_publisher_openStream).">DANStream</a> instances. </p>
<p>If AbsoluteTime = 0 in the configuration entry, calls <a class="el" href="classMARTe_1_1DANStream.html#ab29eba0fc8619c3326c5b73dd9bd70c6" title="Sets the starting absolute time to be used by the PutData.">DANStream::SetAbsoluteStartTime</a> with the current time given by tcn_get_time. </p><dl class="section return"><dt>Returns</dt><dd>ok if tcn_get_time succeeds. </dd></dl>

</div>
</div>
<a id="abd35ab92e9079c34a340dbfc8b58b41e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd35ab92e9079c34a340dbfc8b58b41e">&#9670;&nbsp;</a></span>SetConfiguredDatabase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::DANSource::SetConfiguredDatabase </td>
          <td>(</td>
          <td class="paramtype">StructuredDataI &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Final verification of all the parameters and setup of the <a class="el" href="classMARTe_1_1DANStream.html" title="Wraps a DAN stream (see dan_publisher_openStream).">DANStream</a> instances. </p>
<p>This method verifies that all the parameters (e.g. number of samples) requested by the GAMs interacting with this DataSource are valid and consistent with the parameters set during the initialisation phase. In particular the following conditions shall be met:</p><ul>
<li>If relevant, the Trigger signal shall have type uint8</li>
<li>If relevant, the Time signal shall have type uint32, int32, uint64 or int64</li>
<li>The number of samples of all the DAN signals is one.</li>
<li>For every signal either the Period or the SamplingFrequency is specified.</li>
<li>At least one DAN signal (apart from the eventual Trigger and Time signal) is set.</li>
</ul>
<p>A <a class="el" href="classMARTe_1_1DANStream.html" title="Wraps a DAN stream (see dan_publisher_openStream).">DANStream</a> instance will be created for every different signal_type/sampling_frequency pair. </p><dl class="section return"><dt>Returns</dt><dd>true if all the parameters are valid. </dd></dl>

</div>
</div>
<a id="a5f075b6d782426933be7e9c018a0f916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f075b6d782426933be7e9c018a0f916">&#9670;&nbsp;</a></span>Synchronise()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::DANSource::Synchronise </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls PutData on all the <a class="el" href="classMARTe_1_1DANStream.html" title="Wraps a DAN stream (see dan_publisher_openStream).">DANStream</a> instances. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the <a class="el" href="classMARTe_1_1DANStream.html#a9a6aa6e4a827c1d5af489afe1bddba49" title="Streams the signals data into DAN.">DANStream::PutData</a> returns true on all the streams. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/codac-dev/MARTe2Project/GIT/MARTe2-components/Source/Components/DataSources/DAN/<a class="el" href="DANSource_8h_source.html">DANSource.h</a></li>
<li>/home/codac-dev/MARTe2Project/GIT/MARTe2-components/Source/Components/DataSources/DAN/<a class="el" href="DANSource_8cpp.html">DANSource.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.0
</small></address>
</body>
</html>
