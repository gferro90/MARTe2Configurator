<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>MARTe2-components: MARTe::RealTimeThreadAsyncBridge Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MARTe2-components
   </div>
   <div id="projectbrief">C++ real-time application development framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>MARTe</b></li><li class="navelem"><a class="el" href="classMARTe_1_1RealTimeThreadAsyncBridge.html">RealTimeThreadAsyncBridge</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classMARTe_1_1RealTimeThreadAsyncBridge-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MARTe::RealTimeThreadAsyncBridge Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Allows to share asynchronously signals among two or more real time threads.  
 <a href="classMARTe_1_1RealTimeThreadAsyncBridge.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="RealTimeThreadAsyncBridge_8h_source.html">RealTimeThreadAsyncBridge.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MARTe::RealTimeThreadAsyncBridge:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classMARTe_1_1RealTimeThreadAsyncBridge.png" usemap="#MARTe::RealTimeThreadAsyncBridge_map" alt=""/>
  <map id="MARTe::RealTimeThreadAsyncBridge_map" name="MARTe::RealTimeThreadAsyncBridge_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aff7ad309d3eae44e717bebee5af9e976"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff7ad309d3eae44e717bebee5af9e976"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1RealTimeThreadAsyncBridge.html#aff7ad309d3eae44e717bebee5af9e976">RealTimeThreadAsyncBridge</a> ()</td></tr>
<tr class="memdesc:aff7ad309d3eae44e717bebee5af9e976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:aff7ad309d3eae44e717bebee5af9e976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0c3facb5a6856f4e69c2e93fba80e4"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1RealTimeThreadAsyncBridge.html#a0d0c3facb5a6856f4e69c2e93fba80e4">~RealTimeThreadAsyncBridge</a> ()</td></tr>
<tr class="memdesc:a0d0c3facb5a6856f4e69c2e93fba80e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a0d0c3facb5a6856f4e69c2e93fba80e4">More...</a><br /></td></tr>
<tr class="separator:a0d0c3facb5a6856f4e69c2e93fba80e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d783dccb9862e4ebdfa72795dd9908"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1RealTimeThreadAsyncBridge.html#ab7d783dccb9862e4ebdfa72795dd9908">Initialise</a> (StructuredDataI &amp;data)</td></tr>
<tr class="separator:ab7d783dccb9862e4ebdfa72795dd9908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36fa9100c71f6e8d42fa3adc0cd02e3a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1RealTimeThreadAsyncBridge.html#a36fa9100c71f6e8d42fa3adc0cd02e3a">SetConfiguredDatabase</a> (StructuredDataI &amp;data)</td></tr>
<tr class="memdesc:a36fa9100c71f6e8d42fa3adc0cd02e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates the memory for the state variables.  <a href="#a36fa9100c71f6e8d42fa3adc0cd02e3a">More...</a><br /></td></tr>
<tr class="separator:a36fa9100c71f6e8d42fa3adc0cd02e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56013590579dfd068aa7d717c16997e5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1RealTimeThreadAsyncBridge.html#a56013590579dfd068aa7d717c16997e5">Synchronise</a> ()</td></tr>
<tr class="memdesc:a56013590579dfd068aa7d717c16997e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">NOOP.  <a href="#a56013590579dfd068aa7d717c16997e5">More...</a><br /></td></tr>
<tr class="separator:a56013590579dfd068aa7d717c16997e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03420265d0cf765164eb6ce2d50b0b26"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1RealTimeThreadAsyncBridge.html#a03420265d0cf765164eb6ce2d50b0b26">PrepareNextState</a> (const char8 *const currentStateName, const char8 *const nextStateName)</td></tr>
<tr class="memdesc:a03420265d0cf765164eb6ce2d50b0b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises the variables that depends by the application state.  <a href="#a03420265d0cf765164eb6ce2d50b0b26">More...</a><br /></td></tr>
<tr class="separator:a03420265d0cf765164eb6ce2d50b0b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5855b77ca102d805fa9f7a30b4037f3f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1RealTimeThreadAsyncBridge.html#a5855b77ca102d805fa9f7a30b4037f3f">GetInputOffset</a> (const uint32 signalIdx, const uint32 numberOfSamples, uint32 &amp;offset)</td></tr>
<tr class="separator:a5855b77ca102d805fa9f7a30b4037f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0aa7a17f7f746d25e8afd9413e95520"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1RealTimeThreadAsyncBridge.html#ac0aa7a17f7f746d25e8afd9413e95520">GetOutputOffset</a> (const uint32 signalIdx, const uint32 numberOfSamples, uint32 &amp;offset)</td></tr>
<tr class="separator:ac0aa7a17f7f746d25e8afd9413e95520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6852ac168aded23e32ef32e27f8b5662"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1RealTimeThreadAsyncBridge.html#a6852ac168aded23e32ef32e27f8b5662">TerminateInputCopy</a> (const uint32 signalIdx, const uint32 offset, const uint32 numberOfSamples)</td></tr>
<tr class="separator:a6852ac168aded23e32ef32e27f8b5662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82df8a6aecd9718ae15bfa63c0f9d5f0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1RealTimeThreadAsyncBridge.html#a82df8a6aecd9718ae15bfa63c0f9d5f0">TerminateOutputCopy</a> (const uint32 signalIdx, const uint32 offset, const uint32 numberOfSamples)</td></tr>
<tr class="separator:a82df8a6aecd9718ae15bfa63c0f9d5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0339bc8af630105caf972aae696c33f7"><td class="memItemLeft" align="right" valign="top">virtual const char8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1RealTimeThreadAsyncBridge.html#a0339bc8af630105caf972aae696c33f7">GetBrokerName</a> (StructuredDataI &amp;data, const SignalDirection direction)</td></tr>
<tr class="separator:a0339bc8af630105caf972aae696c33f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a86e928e2d70bff8f30781b2444d53944"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86e928e2d70bff8f30781b2444d53944"></a>
volatile int32 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1RealTimeThreadAsyncBridge.html#a86e928e2d70bff8f30781b2444d53944">spinlocksRead</a></td></tr>
<tr class="memdesc:a86e928e2d70bff8f30781b2444d53944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Denoted the current number of readers for each buffer. <br /></td></tr>
<tr class="separator:a86e928e2d70bff8f30781b2444d53944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93d9a3b789f10f12984d27668a650fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab93d9a3b789f10f12984d27668a650fc"></a>
FastPollingMutexSem *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1RealTimeThreadAsyncBridge.html#ab93d9a3b789f10f12984d27668a650fc">spinlocksWrite</a></td></tr>
<tr class="memdesc:ab93d9a3b789f10f12984d27668a650fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A semaphore to lock the buffer that is going to be written. <br /></td></tr>
<tr class="separator:ab93d9a3b789f10f12984d27668a650fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab116e5394936780295c0b9dcff75f835"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab116e5394936780295c0b9dcff75f835"></a>
uint32 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1RealTimeThreadAsyncBridge.html#ab116e5394936780295c0b9dcff75f835">whatIsNewestCounter</a></td></tr>
<tr class="memdesc:ab116e5394936780295c0b9dcff75f835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to denote the oldest and newest written buffers. <br /></td></tr>
<tr class="separator:ab116e5394936780295c0b9dcff75f835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670cfebb378f903a620b6ade16ac4b9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a670cfebb378f903a620b6ade16ac4b9a"></a>
uint32 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1RealTimeThreadAsyncBridge.html#a670cfebb378f903a620b6ade16ac4b9a">whatIsNewestGlobCounter</a></td></tr>
<tr class="memdesc:a670cfebb378f903a620b6ade16ac4b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The counter incremented for each signal at the end of the write operation. <br /></td></tr>
<tr class="separator:a670cfebb378f903a620b6ade16ac4b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2ae23a1f5fc47f3d8ecbc106e593d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a2ae23a1f5fc47f3d8ecbc106e593d0"></a>
uint32 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1RealTimeThreadAsyncBridge.html#a9a2ae23a1f5fc47f3d8ecbc106e593d0">writeOp</a></td></tr>
<tr class="memdesc:a9a2ae23a1f5fc47f3d8ecbc106e593d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of write operations for each signal. <br /></td></tr>
<tr class="separator:a9a2ae23a1f5fc47f3d8ecbc106e593d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2480d51f1482ef0d1e114ddcee0a1b"><td class="memItemLeft" align="right" valign="top">uint32 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1RealTimeThreadAsyncBridge.html#a8c2480d51f1482ef0d1e114ddcee0a1b">writeOpCounter</a></td></tr>
<tr class="memdesc:a8c2480d51f1482ef0d1e114ddcee0a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialised equal to <em>writeOp</em> and decremented in TerminateOutputCopy.  <a href="#a8c2480d51f1482ef0d1e114ddcee0a1b">More...</a><br /></td></tr>
<tr class="separator:a8c2480d51f1482ef0d1e114ddcee0a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b090141a55424ac97937d60a3496397"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b090141a55424ac97937d60a3496397"></a>
uint32 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1RealTimeThreadAsyncBridge.html#a5b090141a55424ac97937d60a3496397">offsetStore</a></td></tr>
<tr class="memdesc:a5b090141a55424ac97937d60a3496397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the signal offset in case of more write operations. <br /></td></tr>
<tr class="separator:a5b090141a55424ac97937d60a3496397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab987c132f8a9577130304698fe874bce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab987c132f8a9577130304698fe874bce"></a>
TimeoutType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMARTe_1_1RealTimeThreadAsyncBridge.html#ab987c132f8a9577130304698fe874bce">resetTimeout</a></td></tr>
<tr class="memdesc:ab987c132f8a9577130304698fe874bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">The timeout in millisecs to lock the other <em>spinlocksWrite</em> semaphores in case of overflow of <em>whatIsNewestCounter</em> (to avoid a priority inversion) <br /></td></tr>
<tr class="separator:ab987c132f8a9577130304698fe874bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Allows to share asynchronously signals among two or more real time threads. </p>
<p>For each signal, the writer GAM finds the oldest available buffer written to write on and after the write operation it sets it as the newest. The reader GAMs attempt to read on the newest written available buffer. The mutual access between readers and writer is guaranteed by spinlock semaphores, one for each buffer of each signal. If no buffer is available for the writer, the GetOutputOffset function returns false. The same happens if there is no buffer available for the reader (impossible if more than one buffer has been declared), in this case the GetInputOffset returns false.</p>
<pre>
+ThisDataSourceIObjectName = {
   Class = <a class="el" href="classMARTe_1_1RealTimeThreadAsyncBridge.html" title="Allows to share asynchronously signals among two or more real time threads. ">RealTimeThreadAsyncBridge</a>
   NumberOfBuffers = 3 //Optional but &lt; 64. Default = 1. Each buffer contains a copy of each signal.
   HeapName = "Default" //Optional. Default = GlobalObjectsDatabase::Instance()-&gt;GetStandardHeap();
   ResetMSecTimeout = 1 //Optional. Default = TTInfiniteWait. The TerminateOutputCopy function can block when the counter used to newest written buffer overflows and needs to be reset.
                                                              If the reader should wait for this counter to be properly reset then the ResetMSecTimeout should
                                                              be increased to a large number. If instead the reader does not mind to get oldest buffer (instead of the newest) while this reset operation
                                                              is being performed, the ResetMSecTimeout should be set to 0.
                                                              This overflow will occur every 2**32-1 writes, which at e.g. 1 kHz frequency, will occur every ~49 days).
   Signals = {
       +*NAME = {
           +Type = BasicType|StructuredType
           +NumberOfDimensions = 0|1|2
           +NumberOfElements = NUMBER&gt;0
      }
   }
}
</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0d0c3facb5a6856f4e69c2e93fba80e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MARTe::RealTimeThreadAsyncBridge::~RealTimeThreadAsyncBridge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Frees the memory </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a0339bc8af630105caf972aae696c33f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char8 * MARTe::RealTimeThreadAsyncBridge::GetBrokerName </td>
          <td>(</td>
          <td class="paramtype">StructuredDataI &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SignalDirection&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>DataSourceI::GetBrokerName </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>. </dd></dl>

</div>
</div>
<a class="anchor" id="a5855b77ca102d805fa9f7a30b4037f3f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::RealTimeThreadAsyncBridge::GetInputOffset </td>
          <td>(</td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>signalIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>numberOfSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32 &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>DataSourceI::GetInputOffset</dd></dl>
<p>Checks the last written available buffer and returns its offset. The atomic variable <em>spinlocksRead</em>, denoting the number of readers on that buffer is incremented. The writer can not write on that buffer if this atomic variable is greater than zero. </p><dl class="section return"><dt>Returns</dt><dd>false if no buffer is available. This happens only if only one buffer is defined and the writer is writing on it. </dd></dl>

</div>
</div>
<a class="anchor" id="ac0aa7a17f7f746d25e8afd9413e95520"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::RealTimeThreadAsyncBridge::GetOutputOffset </td>
          <td>(</td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>signalIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>numberOfSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32 &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>DataSourceI::GetOutputOffset</dd></dl>
<p>Checks the oldest written available buffer and returns its offset. the semaphore <em>spinlocksWrite</em>, is locked on that buffer. The readers can not read on that buffer while the semaphore is locked. </p><dl class="section return"><dt>Returns</dt><dd>false if no buffer is available because the readers are using all of them. </dd></dl>

</div>
</div>
<a class="anchor" id="ab7d783dccb9862e4ebdfa72795dd9908"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::RealTimeThreadAsyncBridge::Initialise </td>
          <td>(</td>
          <td class="paramtype">StructuredDataI &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>DataSourceI::Initialise</dd></dl>
<p>Checks that (NumberOfBuffers &lt; 64) . NumberOfBuffers = N (&lt;64)<br />
 ResetMSecTimeout = msec (the TerminateOutputCopy can block when the counter used to denote the oldest and newest written buffer overflows and needs to be reset. If the read should wait for this counter to be properly reset then the ResetMSecTimeout should be increased to a large number. If instead the reader does not mind to get oldest buffer (instead of the newest) while this reset operation is being performed, the ResetMSecTimeout should be set to 0. This overflow will occur every 2**32-1 writes, which at e.g. 1 kHz frequency, will occur every ~49 days). </p>

</div>
</div>
<a class="anchor" id="a03420265d0cf765164eb6ce2d50b0b26"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::RealTimeThreadAsyncBridge::PrepareNextState </td>
          <td>(</td>
          <td class="paramtype">const char8 *const&#160;</td>
          <td class="paramname"><em>currentStateName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char8 *const&#160;</td>
          <td class="paramname"><em>nextStateName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialises the variables that depends by the application state. </p>
<p>In the case where signals are written more than one time by the writer GAM and/or signals with more than one range defined, the TerminateOutputCopy function will not unlock the buffer until all the write operations have been completed. In this function the <em>writeOp</em> variable is set as the sum of the write operations for each signal. </p><dl class="section return"><dt>Returns</dt><dd>true. </dd></dl>

</div>
</div>
<a class="anchor" id="a36fa9100c71f6e8d42fa3adc0cd02e3a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::RealTimeThreadAsyncBridge::SetConfiguredDatabase </td>
          <td>(</td>
          <td class="paramtype">StructuredDataI &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates the memory for the state variables. </p>
<p>Checks that the signals have not defined the "Samples" field, because this data source does not support samples. </p><dl class="section return"><dt>Returns</dt><dd>true if for each signal "Samples" is not defined and if the memory is allocated with no errors for the state variables. It returns false otherwse. </dd></dl>

</div>
</div>
<a class="anchor" id="a56013590579dfd068aa7d717c16997e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::RealTimeThreadAsyncBridge::Synchronise </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>NOOP. </p>
<dl class="section return"><dt>Returns</dt><dd>true. </dd></dl>

</div>
</div>
<a class="anchor" id="a6852ac168aded23e32ef32e27f8b5662"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::RealTimeThreadAsyncBridge::TerminateInputCopy </td>
          <td>(</td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>signalIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>numberOfSamples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>DataSourceI::TerminateInputCopy</dd></dl>
<p>Decrements the atomic variable <em>spinlocksRead</em> for the buffer that has just been read. </p>

</div>
</div>
<a class="anchor" id="a82df8a6aecd9718ae15bfa63c0f9d5f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MARTe::RealTimeThreadAsyncBridge::TerminateOutputCopy </td>
          <td>(</td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>signalIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>numberOfSamples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>DataSourceI::TerminateOutputCopy</dd></dl>
<p>If all the write operations for the signal <em>signalIdx</em> have been terminated, it increments the <em>whatIsNewestCounter</em> setting the buffer as the last written. The spinlocksWrite variable is unlocked for the buffer that have just been written. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a8c2480d51f1482ef0d1e114ddcee0a1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32* MARTe::RealTimeThreadAsyncBridge::writeOpCounter</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialised equal to <em>writeOp</em> and decremented in TerminateOutputCopy. </p>
<p>When it reaches zero, the <em>spinlocksWrite</em> semaphore for the signal is unlocked. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/pc/MARTe2Project/GIT/MARTe2-components/Source/Components/DataSources/RealTimeThreadAsyncBridge/<a class="el" href="RealTimeThreadAsyncBridge_8h_source.html">RealTimeThreadAsyncBridge.h</a></li>
<li>/home/pc/MARTe2Project/GIT/MARTe2-components/Source/Components/DataSources/RealTimeThreadAsyncBridge/<a class="el" href="RealTimeThreadAsyncBridge_8cpp.html">RealTimeThreadAsyncBridge.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
